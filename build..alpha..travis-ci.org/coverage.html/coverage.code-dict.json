{"/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/test.js":"/* istanbul instrument in package npmtest_watson_developer_cloud */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/lib.npmtest_watson_developer_cloud.js":"/* istanbul instrument in package npmtest_watson_developer_cloud */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_watson_developer_cloud = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_watson_developer_cloud = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-watson-developer-cloud && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_watson_developer_cloud */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_watson_developer_cloud\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_watson_developer_cloud.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_watson_developer_cloud.rollup.js'] =\n            local.assetsDict['/assets.npmtest_watson_developer_cloud.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_watson_developer_cloud.__dirname +\n                    '/lib.npmtest_watson_developer_cloud.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/index.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * @module watson-developer-cloud\n */\nexports.AlchemyDataNewsV1 = require('./alchemy-data-news/v1');\nexports.AlchemyLanguageV1 = require('./alchemy-language/v1');\nexports.AlchemyVisionV1 = require('./alchemy-vision/v1');\n\nexports.AuthorizationV1 = require('./authorization/v1');\n\nexports.ConversationV1 = require('./conversation/v1');\nexports.ConversationV1Experimental = require('./conversation/v1-experimental');\n\nexports.DialogV1 = require('./dialog/v1');\n\nexports.DiscoveryV1 = require('./discovery/v1');\nexports.DiscoveryV1Experimental = require('./discovery/v1-experimental');\n\nexports.DocumentConversionV1 = require('./document-conversion/v1');\n\nexports.LanguageTranslationV2 = require('./language-translation/v2');\nexports.LanguageTranslatorV2 = require('./language-translator/v2');\n\nexports.NaturalLanguageClassifierV1 = require('./natural-language-classifier/v1');\n\nexports.NaturalLanguageUnderstandingV1 = require('./natural-language-understanding/v1');\n\nexports.PersonalityInsightsV2 = require('./personality-insights/v2');\nexports.PersonalityInsightsV3 = require('./personality-insights/v3');\n\nexports.RetrieveAndRankV1 = require('./retrieve-and-rank/v1');\n\nexports.SpeechToTextV1 = require('./speech-to-text/v1');\n\nexports.TextToSpeechV1 = require('./text-to-speech/v1');\n\nexports.ToneAnalyzerV3 = require('./tone-analyzer/v3');\n\nexports.TradeoffAnalyticsV1 = require('./tradeoff-analytics/v1');\n\nexports.VisualRecognitionV3 = require('./visual-recognition/v3');\n\n// adding shim constructors for backwards compatibility\n\n// 2-d map of snake_case service names & version => constructor function\n// e.g. servicesByVersion.text_to_speech.v1 === exports.TextToSpeechV1;\nconst servicesByVersion = {};\nObject.keys(exports).forEach(function(key) {\n  const Service = exports[key];\n  const name = Service.prototype.name;\n  const version = Service.prototype.version;\n  servicesByVersion[name] = servicesByVersion[name] || {};\n  servicesByVersion[name][version] = Service;\n});\n\nObject.keys(servicesByVersion).forEach(function(serviceName) {\n  Object.defineProperty(exports, serviceName, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function(options) {\n      options = options || {};\n\n      // previously, AlchemyAPI did not require a version to be specified\n      if (serviceName.indexOf('alchemy_') === 0) {\n        options.version = 'v1';\n      }\n\n      const Service = servicesByVersion[serviceName][options.version];\n\n      if (!Service) {\n        throw new Error('Unable to find ' + serviceName + ' version ' + options.version);\n      }\n\n      return new Service(options);\n    }\n  });\n});\n\n// removed services\n// we don't want these services listed (so non-enumerable), but we do want a clear error message\n// if old code happens to try using one\n['concept_insights', 'relationship_extraction', 'message_resonance', 'question_and_answer', 'visual_insights', 'concept_expansion'].forEach(function(\n  serviceName\n) {\n  Object.defineProperty(exports, serviceName, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function() {\n      throw new Error('The ' + serviceName + ' service is no longer available');\n    }\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/alchemy-data-news/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst extend = require('extend');\nconst requestFactory = require('../lib/requestwrapper');\nconst util = require('util');\nconst BaseServiceAlchemy = require('../lib/base_service_alchemy');\nconst errorFormatter = require('../lib/alchemy_error_formatter');\n\n/**\n * @param {Object} options\n * @constructor\n */\nfunction AlchemyDataNewsV1(options) {\n  BaseServiceAlchemy.call(this, options);\n}\nutil.inherits(AlchemyDataNewsV1, BaseServiceAlchemy);\n\nAlchemyDataNewsV1.prototype.name = 'alchemy_data_news';\nAlchemyDataNewsV1.prototype.version = 'v1';\nAlchemyDataNewsV1.URL = 'https://gateway-a.watsonplatform.net/calls';\n\n/**\n * Extracts a grouped, ranked list of named entities (people, companies,\n * organizations, etc.) from text, a URL or HTML.\n * @param {Object} params\n * @param params.end\n * @param params.start\n * @param {Function} callback\n */\nAlchemyDataNewsV1.prototype.getNews = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/data/GetNews',\n      method: 'GET',\n      json: true,\n      qs: extend({}, params, { outputMode: 'json' }) // change default output to json\n    },\n    requiredParams: ['end', 'start'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, errorFormatter(callback));\n};\n\nmodule.exports = AlchemyDataNewsV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/lib/requestwrapper.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst extend = require('extend');\nconst request = require('request');\nconst pkg = require('../package.json');\nconst helper = require('./helper');\nconst parseString = require('string');\nconst readableStream = require('stream').PassThrough;\nconst isBrowser = typeof window === 'object';\n\n/**\n * @private\n * @param {String} path\n * @param {Object} params\n * @return {String}\n */\nfunction parsePath(path, params) {\n  if (!path || !params) {\n    return path;\n  }\n  const escapedParams = {};\n  Object.keys(params).forEach(function(value) {\n    escapedParams[value] = encodeURIComponent(params[value]);\n  });\n\n  return parseString(path).template(escapedParams, '{', '}').s;\n}\n\n/**\n * Check if the service/request have error and try to format them.\n * @param  {Function} cb the request callback\n * @private\n */\nfunction formatErrorIfExists(cb) {\n  return function(error, response, body) {\n    // eslint-disable-line complexity\n\n    // If we have an error return it.\n    if (error) {\n      // first ensure that it's an instanceof Error\n      if (!(error instanceof Error)) {\n        body = error;\n        error = new Error(error.message || error.error || error);\n        error.body = body;\n      }\n      cb(error, body, response);\n      return;\n    }\n\n    try {\n      body = JSON.parse(body);\n    } catch (e) {\n      // if it fails, just return the body as a string\n    }\n\n    // If we have a response and it contains an error\n    if (body && (body.error || body.error_code)) {\n      // visual recognition sets body.error to a json object with code/description/error_id instead of putting them top-left\n      if (typeof body.error === 'object' && body.error.description) {\n        const errObj = body.error; // just in case there's a body.error.error...\n        Object.keys(body.error).forEach(function(key) {\n          body[key] = body.error[key];\n        });\n        body.error = errObj.description;\n      }\n      // language translaton returns json with error_code and error_message\n      error = new Error(body.error || body.error_message || 'Error Code: ' + body.error_code);\n      error.code = body.error_code;\n      Object.keys(body).forEach(function(key) {\n        error[key] = body[key];\n      });\n      body = null;\n    }\n\n    // If we still don't have an error and there was an error...\n    if (!error && (response.statusCode < 200 || response.statusCode >= 300)) {\n      error = new Error(body);\n      error.code = response.statusCode;\n      if (error.code === 401 || error.code === 403) {\n        error.body = error.message;\n        error.message = 'Unauthorized: Access is denied due to invalid credentials.';\n      }\n      body = null;\n    }\n    cb(error, body, response);\n  };\n}\n\n/**\n * Creates the request.\n * 1. Merge default options with user provided options\n * 2. Checks for missing parameters\n * 3. Encode path and query parameters\n * 4. Call the api\n * @private\n * @return {ReadableStream|undefined}\n */\nfunction createRequest(parameters, _callback) {\n  let missingParams = null;\n  const options = extend(true, {}, parameters.defaultOptions, parameters.options);\n  const path = options.path;\n  const body = options.body; // application/json or text/plain\n  const form = options.form; // application/x-www-form-urlencoded\n  const formData = options.formData; // application/x-www-form-urlencoded\n  const qs = options.qs; // Query parameters\n\n  // Provide a default callback if it doesn't exists\n  const callback = typeof _callback === 'function' ? _callback /* no op */ : (function() {});\n\n  // Missing parameters\n  if (parameters.options.requiredParams) {\n    // eslint-disable-next-line no-console\n    console.warn(new Error('requiredParams set on parameters.options - it should be set directly on parameters'));\n  }\n\n  missingParams = helper.getMissingParams(parameters.originalParams || extend({}, qs, body, form, formData, path), parameters.requiredParams);\n\n  if (missingParams) {\n    if (typeof _callback === 'function') {\n      return callback(missingParams);\n    } else {\n      const errorStream = readableStream();\n      setTimeout(\n        function() {\n          errorStream.emit('error', missingParams);\n        },\n        0\n      );\n      return errorStream;\n    }\n  }\n\n  // Path params\n  options.url = parsePath(options.url, path);\n  delete options.path;\n\n  // Headers\n  options.headers = extend({}, options.headers);\n\n  if (!isBrowser) {\n    options.headers['User-Agent'] = pkg.name + '-nodejs-' + pkg.version;\n  }\n\n  // Query params\n  if (options.qs && Object.keys(options.qs).length > 0) {\n    options.useQuerystring = true;\n  }\n\n  // Add service default endpoint if options.url start with /\n  if (options.url.charAt(0) === '/') {\n    options.url = parameters.defaultOptions.url + options.url;\n  }\n\n  // Compression support\n  options.gzip = true;\n\n  return request(options, formatErrorIfExists(callback));\n}\n\nmodule.exports = createRequest;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/lib/helper.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nmodule.exports = {\n  stripTrailingSlash: function(url) {\n    // Match a forward slash / at the end of the string ($)\n    return url.replace(/\\/$/, '');\n  },\n  /**\n   * Validates that all required params are provided\n   * @param params\n   * @param requires\n   * @return {Error|null}\n   */\n  getMissingParams: function(params, requires) {\n    let missing;\n\n    if (!requires) {\n      return null;\n    } else if (!params) {\n      missing = requires;\n    } else {\n      missing = [];\n\n      requires.forEach(function(require) {\n        if (!params[require]) {\n          missing.push(require);\n        }\n      });\n    }\n\n    return missing.length > 0 ? new Error('Missing required parameters: ' + missing.join(', ')) : null;\n  },\n  /**\n   * Return true if 'text' is html\n   * @param  {String}  text The 'text' to analyze\n   * @return {Boolean}      true if 'text' has html tags\n   */\n  isHTML: function(text) {\n    return /<[a-z][\\s\\S]*>/i.test(text);\n  },\n  /**\n   * Returns the first match from formats that is key the params map\n   * otherwise null\n   * @param  {Object}  params   The parameters\n   * @param  {Array}  requires The keys we want to check\n    */\n  getFormat: function(params, formats) {\n    if (!formats || !params) {\n      return null;\n    }\n\n    for (let i = 0; i < formats.length; i++) {\n      if (formats[i] in params) {\n        return formats[i];\n      }\n    }\n    return null;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/lib/base_service_alchemy.js":"'use strict';\n\nconst util = require('util');\nconst extend = require('extend');\nconst BaseService = require('./base_service');\n\n/**\n * Variation of BaseService for Alchemy API services (and Visual Recognition v3)\n * @param {Object} options\n * @constructor\n * @abstract\n * @private\n */\nfunction BaseServiceAlchemy(options) {\n  BaseService.call(this, options);\n}\nutil.inherits(BaseServiceAlchemy, BaseService);\n\n/**\n * Grab the api key\n *\n * @param {Object} options\n * @private\n */\nBaseServiceAlchemy.prototype.initCredentials = function(options) {\n  options.apikey = options.apikey || options.api_key;\n  options = extend(\n    {},\n    this.getCredentialsFromBluemix('alchemy_api'), // this is the same for all Alchemy* services\n    this.getCredentialsFromEnvironment(this.name),\n    options\n  );\n  if (!options.use_unauthenticated) {\n    if (!options.apikey) {\n      throw new Error('Argument error: api_key was not specified');\n    }\n    // Per documentation, Alchemy* services use `apikey`, but Visual Recognition uses (`api_key`)\n    // (Either will work in most cases, but there are a few exceptions.)\n    options.qs = extend({ apikey: options.apikey }, options.qs);\n  }\n  return options;\n};\n\n/**\n * Pulls api_key from SERVICE_NAME_API_KEY env property\n *\n * @param {String} name\n * @return {{api_key: String|undefined}}\n */\nBaseServiceAlchemy.prototype.getCredentialsFromEnvironment = function(name) {\n  return {\n    apikey: process.env[name.toUpperCase() + '_API_KEY'],\n    url: process.env[name + '_URL']\n  };\n};\n\n/**\n * Retrieve this service's credentials - useful for passing to the authorization service\n * @type {BaseService}\n * @return {{username: String, password: String, url: String}}\n */\nBaseServiceAlchemy.prototype.getCredentials = function() {\n  return {\n    apikey: this._options.apikey,\n    url: this._options.url\n  };\n};\n\nmodule.exports = BaseServiceAlchemy;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/lib/base_service.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\nconst extend = require('extend');\nconst vcapServices = require('vcap_services');\nconst helper = require('./helper');\nconst request = require('request');\nconst bufferFrom = require('buffer-from'); // new Buffer() is deprecated, replaced with Buffer.from() in node v4.5.0+ - this uses the new api when possible but falls back to the old one otherwise\n\n/**\n * Internal base class that other services inherit from\n * @param {Object} options\n * @param {String} [options.username] - required unless use_unauthenticated is set\n * @param {String} [options.password] - required unless use_unauthenticated is set\n * @param {Boolean} [options.use_unauthenticated] - skip credential requirement\n * @param {Object} [options.headers]\n * @param {Boolean} [options.headers.X-Watson-Learning-Opt-Out=false] - opt-out of data collection\n * @param {String} [options.url] - override default service base url\n * @private\n * @abstract\n * @constructor\n */\nfunction BaseService(user_options) {\n  if (!(this instanceof BaseService)) {\n    // it might be better to just create a new instance and return that.. but that can't be done here, it has to be done in each individual service. So this is still a good failsafe even in that case.\n    throw new Error('\"new\" keyword required to create Watson service instances');\n  }\n  let options = extend({}, user_options);\n\n  options = this.initCredentials(options);\n\n  if (options.url) {\n    options.url = helper.stripTrailingSlash(options.url);\n  }\n\n  this._options = extend({ qs: {}, url: this.constructor.URL }, this.serviceDefaults, options);\n}\n\n/**\n * @private\n * @param {Object} options\n * @return {*}\n */\nBaseService.prototype.initCredentials = function(options) {\n  if (options.token) {\n    options.headers = options.headers || {};\n    options.headers['X-Watson-Authorization-Token'] = options.token;\n    return options;\n  }\n\n  options.jar = request.jar();\n\n  // Get credentials from environment properties or Bluemix\n  // but prefer credentials provided pragmatically!\n  options = extend({}, this.getCredentialsFromBluemix(this.name), this.getCredentialsFromEnvironment(this.name), options);\n\n  if (!options.use_unauthenticated) {\n    if (!options.username || !options.password) {\n      throw new Error('Argument error: username and password are required unless use_unauthenticated is set');\n    }\n\n    // Calculate and add Authorization header to base options\n    const authHeader = {\n      Authorization: 'Basic ' + bufferFrom(options.username + ':' + options.password).toString('base64')\n    };\n    options.headers = extend(authHeader, options.headers);\n  }\n\n  return options;\n};\n\n/**\n * Pulls credentials from env properties\n *\n * Property checked is uppercase service.name suffixed by _USERNAME and _PASSWORD\n *\n * For example, if service.name is speech_to_text, env properties are SPEECH_TO_TEXT_USERNAME and SPEECH_TO_TEXT_PASSWORD\n *\n * @private\n * @param name\n * @return {{username: String|undefined, password: String|undefined, url: String|undefined}}\n */\nBaseService.prototype.getCredentialsFromEnvironment = function(name) {\n  name = name.toUpperCase();\n  return {\n    username: process.env[name + '_USERNAME'],\n    password: process.env[name + '_PASSWORD'],\n    url: process.env[name + '_URL']\n  };\n};\n\n/**\n * Pulls credentials from VCAP_SERVICES env property that bluemix sets\n *\n * @private\n * @return {Object}\n */\nBaseService.prototype.getCredentialsFromBluemix = function(vcap_services_name) {\n  return vcapServices.getCredentials(vcap_services_name);\n};\n\n/**\n * Retrieve this service's credentials - useful for passing to the authorization service\n *\n * Only returns a URL when token auth is used.\n *\n * @return {{username: String, password: String, url: String}}\n */\nBaseService.prototype.getCredentials = function() {\n  return {\n    username: this._options.username,\n    password: this._options.password,\n    url: this._options.url\n  };\n};\n\nmodule.exports = BaseService;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/lib/alchemy_error_formatter.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst extend = require('extend');\n\nmodule.exports = function alchemyErrorFormatter(cb) {\n  return function(err, result, response) {\n    if (err) {\n      cb(err, result);\n    } else {\n      if (result.status !== 'OK') {\n        err = new Error(result.statusInfo || response['headers']['x-alchemyapi-error-msg']);\n        err.code = 400;\n        err.body = result;\n        extend(err, result);\n        result = null;\n      }\n      cb(err, result);\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/alchemy-language/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst extend = require('extend');\nconst util = require('util');\nconst BaseServiceAlchemy = require('../lib/base_service_alchemy');\nconst requestFactory = require('../lib/requestwrapper');\n// IMPORTANT:\n// Due to the current design, the URL must be the last key on each endpoint or\n// it could inadvertently clobber a url query param in the users request.\n// see #236\nconst endpoints = require('../lib/alchemy_endpoints.json');\nconst helper = require('../lib/helper');\nconst pick = require('object.pick');\nconst errorFormatter = require('../lib/alchemy_error_formatter');\n\n/**\n * @privte\n * @param method\n * @return {Function}\n */\nfunction createRequest(method) {\n  return function(_params, callback) {\n    const params = _params || {};\n    const accepted_formats = Object.keys(endpoints[method]);\n    const format = helper.getFormat(params, accepted_formats);\n\n    if (format === null) {\n      callback(new Error('Missing required parameters: ' + accepted_formats.join(', ') + ' needs to be specified'));\n      return;\n    }\n\n    const parameters = {\n      options: {\n        url: endpoints[method][format],\n        method: 'POST',\n        json: true,\n        qs: pick(params, ['model']),\n        form: extend({}, params, { outputMode: 'json' }) // change default output to json\n      },\n      defaultOptions: this._options // eslint-disable-line no-invalid-this\n    };\n    return requestFactory(parameters, errorFormatter(callback));\n  };\n}\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction AlchemyLanguageV1(options) {\n  BaseServiceAlchemy.call(this, options);\n}\nutil.inherits(AlchemyLanguageV1, BaseServiceAlchemy);\nAlchemyLanguageV1.prototype.name = 'alchemy_language';\nAlchemyLanguageV1.prototype.version = 'v1';\nAlchemyLanguageV1.URL = 'https://access.alchemyapi.com/calls';\n\n/**\n * Extracts a grouped, ranked list of named entities (people, companies,\n * organizations, etc.) from text, a URL or HTML.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.entities = createRequest('entities');\n\n/**\n * Extracts the keywords from text, a URL or HTML.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.keywords = createRequest('keywords');\n\n/**\n * Tags the concepts from text, a URL or HTML.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.concepts = createRequest('concepts');\n\n/**\n * Calculates the sentiment for text, a URL or HTML.\n */\nAlchemyLanguageV1.prototype.sentiment = function(params, callback) {\n  const _params = extend({}, params);\n  const service = params.target || params.targets ? 'sentiment_targeted' : 'sentiment';\n  if (Array.isArray(_params.targets)) {\n    _params.targets = _params.targets.join('|');\n  }\n\n  return createRequest(service).call(this, _params, callback);\n};\n/**\n * Extracts the cleaned text (removes ads, navigation, etc.) for a URL or HTML.\n * if raw = true, extracts the cleaned text (removes ads, navigation, etc.).\n */\nAlchemyLanguageV1.prototype.text = function(params, callback) {\n  const service = params && params.raw ? 'text_raw' : 'text';\n  return createRequest(service).call(this, params, callback);\n};\n\n/**\n * Extracts the authors from a URL or HTML.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.authors = createRequest('authors');\n\n/**\n * Detects the language for text, a URL or HTML.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.language = createRequest('language');\n\n/**\n * Extracts the title for a URL or HTML.\n *\n * @see http://www.alchemyapi.com/api/text/proc.html\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.title = createRequest('title');\n\n/**\n * Extracts the relations for text, a URL or HTML.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.relations = createRequest('relations');\n\n/**\n * Categorizes the text for text, a URL or HTML.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.category = createRequest('category');\n\n/**\n * Extracts the publication date from a webpage or HTML file.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.publicationDate = createRequest('publication_date');\n\n/**\n * Finds dates in the source text, including relative dates like \"next Tuesday\"\n * if an anchorDate is set.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.dates = createRequest('extract_dates');\n\n/**\n * Detects the RSS/ATOM feeds for a URL or HTML.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.feeds = createRequest('feeds');\n\n/**\n * Parses the microformats for a URL or HTML.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.microformats = createRequest('microformats');\n\n/**\n * Categorized through the taxonomy call for text, HTML, or a URL.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.taxonomy = createRequest('taxonomy');\n\n/**\n * Combines multiple API operations into a single call.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.combined = createRequest('combined');\n\n/**\n * Detects emotions (anger, disgust, fear, joy, and sadness)\n * for text, HTML, or a URL.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.emotion = function(params, callback) {\n  const _params = extend({}, params);\n  const service = params.target || params.targets ? 'emotion_targeted' : 'emotion';\n  if (Array.isArray(_params.targets)) {\n    _params.targets = _params.targets.join('|');\n  }\n\n  return createRequest(service).call(this, _params, callback);\n};\n\n/**\n * Finds entities and their relationships\n * for text, HTML, or a URL.\n * @method\n * @param {Object} params\n * @param {Function} callback\n */\nAlchemyLanguageV1.prototype.typedRelations = createRequest('typed_relations');\n\nmodule.exports = AlchemyLanguageV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/alchemy-vision/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst endpoints = require('../lib/alchemy_endpoints.json');\nconst helper = require('../lib/helper');\nconst isStream = require('isstream');\nconst omit = require('object.omit');\nconst fs = require('fs');\nconst util = require('util');\nconst BaseServiceAlchemy = require('../lib/base_service_alchemy');\nconst errorFormatter = require('../lib/alchemy_error_formatter');\n\n/**\n * @private\n * @param method\n * @return {Function}\n */\nfunction createRequest(method) {\n  return function(_params, callback) {\n    const params = _params || {};\n    const accepted_formats = Object.keys(endpoints[method]);\n    const format = helper.getFormat(params, accepted_formats);\n\n    if (format === null) {\n      callback(new Error('Missing required parameters: ' + accepted_formats.join(', ') + ' needs to be specified'));\n      return;\n    }\n    // always return json\n    params.outputMode = 'json';\n\n    const parameters = {\n      options: {\n        url: endpoints[method][format],\n        method: 'POST'\n      },\n      defaultOptions: this._options // eslint-disable-line no-invalid-this\n    };\n\n    if (!params.image || !isStream(params.image)) {\n      // url or base64 images are considered 'not-raw'\n      if (params.image) {\n        params.imagePostMode = 'not-raw';\n      }\n      // send the parameters as form url-encoded\n      parameters.options.form = params;\n      return requestFactory(parameters, errorFormatter(callback));\n    } else {\n      params.imagePostMode = 'raw';\n      // send the parameters as query parameters\n      parameters.options.qs = omit(params, ['image']);\n      // add the content-length to the headers\n      parameters.options.headers = {\n        'Content-Length': fs.statSync(params.image.path).size\n      };\n      return params.image.pipe(requestFactory(parameters, errorFormatter(callback)));\n    }\n  };\n}\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction AlchemyVisionV1(options) {\n  BaseServiceAlchemy.call(this, options);\n}\nutil.inherits(AlchemyVisionV1, BaseServiceAlchemy);\nAlchemyVisionV1.prototype.name = 'alchemy_vision';\nAlchemyVisionV1.prototype.version = 'v1';\nAlchemyVisionV1.URL = 'https://access.alchemyapi.com/calls';\n\n/**\n * Tags image with keywords\n */\nAlchemyVisionV1.prototype.getImageKeywords = createRequest('image_keywords');\n\n/**\n * Face detection and Recognition\n */\nAlchemyVisionV1.prototype.recognizeFaces = createRequest('image_recognition');\n\n/**\n * Extracts images from a URL or html\n */\nAlchemyVisionV1.prototype.getImageLinks = createRequest('image_link');\n\n/**\n * Identifies  text in an image\n */\nAlchemyVisionV1.prototype.getImageSceneText = createRequest('image_scene_text');\n\nmodule.exports = AlchemyVisionV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/authorization/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst url = require('url');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n * Authorization Service\n *\n * Generates temporary auth tokens for use in untrusted environments.\n * Tokens expire after one hour.\n *\n * @param {Object} options\n * @param {String} options.username\n * @param {String} options.password\n * @param {String} [options.url] url of the service for which auth tokens are being generated\n * @constructor\n */\nfunction AuthorizationV1(options) {\n  BaseService.call(this, options);\n  this.target_url = options.url;\n  // replace the url to always point to /authorization/api\n  const hostname = url.parse(this._options.url);\n  hostname.pathname = '/authorization/api';\n  this._options.url = url.format(hostname);\n}\nutil.inherits(AuthorizationV1, BaseService);\nAuthorizationV1.prototype.name = 'authorization';\nAuthorizationV1.prototype.version = 'v1';\nAuthorizationV1.URL = 'https://stream.watsonplatform.net/authorization/api';\n\n/**\n * Get a percent-encoded authorization token based on resource query string param\n *\n * @param {Object} [options]\n * @param {String} [options.url] defaults to url supplied to constructor (if any)\n * @param {Function(err, token)} callback - called with a %-encoded token\n */\nAuthorizationV1.prototype.getToken = function(params, callback) {\n  if (typeof params === 'function') {\n    callback = params;\n    params = { url: this.target_url };\n  }\n  if (!params.url) {\n    callback(new Error('Missing required parameters: url'));\n    return;\n  }\n\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v1/token?url=' + params.url\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = AuthorizationV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/conversation/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst pick = require('object.pick');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {Object} options\n * @param {Object} options.version_date\n * @constructor\n */\nfunction ConversationV1(options) {\n  BaseService.call(this, options);\n\n  // Check if 'version_date' was provided\n  if (typeof this._options.version_date === 'undefined') {\n    throw new Error('Argument error: version_date was not specified, use ConversationV1.VERSION_DATE_2017_02_03');\n  }\n  this._options.qs.version = options.version_date;\n}\nutil.inherits(ConversationV1, BaseService);\nConversationV1.prototype.name = 'conversation';\nConversationV1.prototype.version = 'v1';\nConversationV1.URL = 'https://gateway.watsonplatform.net/conversation/api';\n\n/**\n * Initial release\n * @type {string}\n */\nConversationV1.VERSION_DATE_2016_07_11 = '2016-07-11';\n\n/**\n * 9/20 update made changes to response format\n *\n * * context.system.dialog_stack changed from an array of strings to an array of objects\n *\n * Old:\n```json\n \"context\": {\n    \"system\": {\n      \"dialog_stack\": [\n        \"root\"\n      ],\n```\n * New:\n```json\n \"context\": {\n    \"system\": {\n      \"dialog_stack\": [\n        {\n          \"dialog_node\": \"root\"\n        }\n      ],\n```\n *\n * @see http://www.ibm.com/watson/developercloud/doc/conversation/release-notes.html#20-september-2016\n * @type {string}\n */\nConversationV1.VERSION_DATE_2016_09_20 = '2016-09-20';\n\n/**\n * 02/03 Update\n *\n * * Absolute scoring has now been enabled.\n * @see https://www.ibm.com/watson/developercloud/doc/conversation/irrelevant_utterance.html\n *\n * Old:\n ```json\n \"intents\": [\n   { \"intent\" : \"turn_off\", \"confidence\" : 0.54 },\n   { \"intent\" : \"locate_amenity\", \"confidence\" : 0.4},\n   { \"intent\" : \"weather\", \"confidence\" : 0.06}\n ]\n```\n * Previously all intent confidence values summed to 1.0.\n * New:\n```json\n \"intents\": [\n   { \"intent\" : \"turn_off\", \"confidence\" : 0.54 },\n   { \"intent\" : \"locate_amenity\", \"confidence\" : 0.52},\n   { \"intent\" : \"weather\", \"confidence\" : 0.01}\n ]\n```\n * Now each intent is scored individually with a maximum confidence value of 1.\n *\n * * Irrelevant input detection.\n * Previously an intent was always returned regardless of whether the system considered it irrelevant to the\n * training data within the workspace. With Irrelevant input detection the system will now return an empty intent\n * array if the system thinks the input is irrelevant to the workspace content.\n * Old:\n ```json\n \"input\" : { \"text\" : \"what color is the sky?\"},\n \"intents\": [\n { \"intent\" : \"weather\", \"confidence\" : 0.36 },\n { \"intent\" : \"turn_off\", \"confidence\" : 0.33},\n { \"intent\" : \"locate_amenity\", \"confidence\" : 0.31}\n ]\n ```\n * New:\n ```json\n \"input\" : { \"text\" : \"what color is the sky?\"},\n \"intents\": []\n ```\n *\n * @see https://www.ibm.com/watson/developercloud/doc/conversation/release-notes.html#3-february-2017\n * @type {string}\n */\nConversationV1.VERSION_DATE_2017_02_03 = '2017-02-03';\n\n/**\n * Method: message\n *\n * Returns a response to a user utterance.\n *\n * Example response for 2017-02-03 version_date:\n```json\n {\n   \"intents\": [\n     {\n       \"intent\": \"turn_on\",\n       \"confidence\": 0.999103316650195\n     }\n   ],\n   \"entities\": [\n     {\n       \"entity\": \"appliance\",\n       \"location\": [\n         12,\n         18\n       ],\n       \"value\": \"light\"\n     }\n   ],\n   \"input\": {\n     \"text\": \"Turn on the lights\"\n   },\n   \"output\": {\n     \"log_messages\": [],\n     \"text\": [\n       \"Hi. It looks like a nice drive today. What would you like me to do?\"\n     ],\n     \"nodes_visited\": [\n       \"node_1_1467221909631\"\n     ]\n   },\n   \"context\": {\n     \"conversation_id\": \"820334ac-ee79-45b5-aa03-7958dcd0fd34\",\n     \"system\": {\n       \"dialog_stack\": [\n         {\n           \"dialog_node\": \"root\"\n         }\n       ],\n       \"dialog_turn_counter\": 1,\n       \"dialog_request_counter\": 1\n     }\n   }\n }\n```\n *\n *\n *\n * @param {Object} params\n * @param params.workspace_id\n * @param [params.input]\n * @param [params.context]\n * @param [params.alternate_intents=false] - includes other lower-confidence intents in the intents array.\n * @param [params.output]\n * @param [params.entities]\n * @param [params.intents]\n *\n */\nConversationV1.prototype.message = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/message',\n      method: 'POST',\n      json: true,\n      body: pick(params, ['input', 'context', 'alternate_intents', 'output', 'entities', 'intents']),\n      path: pick(params, ['workspace_id'])\n    },\n    requiredParams: ['workspace_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: listWorkspaces\n *\n * Returns the list of workspaces in Watson Conversation Service instance\n *\n * Example Response:\n```json\n {\n   \"workspaces\": [\n     {\n       \"name\": \"Pizza app\",\n       \"created\": \"2015-12-06T23:53:59.153Z\",\n       \"language\": \"en\",\n       \"metadata\": {},\n       \"updated\": \"2015-12-06T23:53:59.153Z\",\n       \"description\": \"Pizza app\",\n       \"workspace_id\": \"pizza_app-e0f3\"\n     }\n   ]\n }\n```\n *\n * @param {Object} [params]\n * @param {Number} [params.page_limit]\n * @param {Boolean} [params.include_count]\n * @param {String} [params.sort]\n * @param {String} [params.cursor]\n * @param {Function} [callback]\n */\nConversationV1.prototype.listWorkspaces = function(params, callback) {\n  if (typeof params === 'function' && !callback) {\n    callback = params;\n    params = null;\n  }\n  const parameters = {\n    options: {\n      url: '/v1/workspaces',\n      method: 'GET',\n      qs: pick(params, ['page_limit', 'include_count', 'sort', 'cursor'])\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: createWorkspace\n *\n * Creates a new workspace\n *\n * Model Schema\n```json\n {\n  \"name\": \"string\",\n  \"description\": \"string\",\n  \"language\": \"string\",\n  \"metadata\": {},\n  \"counterexamples\": [\n    {\n      \"text\": \"string\"\n    }\n  ],\n  \"dialog_nodes\": [\n    {\n      \"dialog_node\": \"string\",\n      \"description\": \"string\",\n      \"conditions\": \"string\",\n      \"parent\": \"string\",\n      \"previous_sibling\": \"string\",\n      \"output\": {\n        \"text\": \"string\"\n      },\n      \"context\": {},\n      \"metadata\": {},\n      \"go_to\": {\n        \"dialog_node\": \"string\",\n        \"selector\": \"string\",\n        \"return\": true\n      }\n    }\n  ],\n  \"entities\": [\n    {\n      \"entity\": \"string\",\n      \"description\": {\n        \"long\": [\n          \"string\"\n        ],\n        \"short\": [\n          \"string\"\n        ],\n        \"examples\": [\n          \"string\"\n        ]\n      },\n      \"type\": \"string\",\n      \"source\": \"string\",\n      \"open_list\": false,\n      \"values\": [\n        {\n          \"value\": \"string\",\n          \"metadata\": {},\n          \"synonyms\": [\n            \"string\"\n          ]\n        }\n      ]\n    }\n  ],\n  \"intents\": [\n    {\n      \"intent\": \"string\",\n      \"description\": \"string\",\n      \"examples\": [\n        {\n          \"text\": \"string\"\n        }\n      ]\n    }\n  ]\n }\n```\n *\n * Example Response\n```json\n {\n  \"name\": \"Pizza app\",\n  \"created\": \"2015-12-06T23:53:59.153Z\",\n  \"language\": \"en\",\n  \"metadata\": {},\n  \"updated\": \"2015-12-06T23:53:59.153Z\",\n  \"description\": \"Pizza app\",\n  \"workspace_id\": \"pizza_app-e0f3\"\n }\n```\n *\n * @param  {Object}  params\n * @param {String} [params.name]\n * @param {String} [params.description]\n * @param {String} [params.language]\n * @param {Object} [params.metadata]\n * @param {Array<Object>} [params.entities]\n * @param {Array<Object>} [params.intents]\n * @param {Array<Object>} [params.dialog_nodes]\n * @param {Array<Object>} [params.counterexamples]\n * @param {Function} [callback]\n *\n */\n\nConversationV1.prototype.createWorkspace = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces',\n      method: 'POST',\n      json: true,\n      body: pick(params, ['name', 'language', 'entities', 'intents', 'dialog_nodes', 'metadata', 'description', 'counterexamples'])\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: getWorkspace\n *\n * Returns information about a specified workspace or return the whole workspace\n *\n * Example Response (with default export value):\n```json\n {\n  \"name\": \"Pizza app\",\n  \"created\": \"2015-12-06T23:53:59.153Z\",\n  \"language\": \"en\",\n  \"metadata\": {},\n  \"updated\": \"2015-12-06T23:53:59.153Z\",\n  \"description\": \"Pizza app\",\n  \"workspace_id\": \"pizza_app-e0f3\"\n }\n```\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {Boolean} [params.export=false] - if true, the full contents of all of the sub-resources are returned\n * @param {Function} [callback]\n */\n\nConversationV1.prototype.getWorkspace = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}',\n      method: 'GET',\n      json: true,\n      qs: pick(params, ['export']),\n      path: pick(params, ['workspace_id'])\n    },\n    requiredParams: ['workspace_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: deleteWorkspace\n *\n * Deletes the specified workspace\n *\n *\n * @param  {Object}   params   { workspace_id: '' }\n * @param params.workspace_id\n * @param {Function} [callback]\n */\n\nConversationV1.prototype.deleteWorkspace = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}',\n      method: 'DELETE',\n      json: true,\n      path: pick(params, ['workspace_id'])\n    },\n    requiredParams: ['workspace_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: updateWorkspace\n *\n * Updates a workspace\n *\n * Example value\n```json\n {\n  \"name\": \"Pizza app\",\n  \"created\": \"2015-12-06T23:53:59.153Z\",\n  \"language\": \"en\",\n  \"metadata\": {},\n  \"description\": \"Pizza app\",\n  \"workspace_id\": \"pizza_app-e0f3\",\n  \"counterexamples\": [\n    {\n      \"text\": \"string\"\n    }\n  ],\n  \"dialog_nodes\": [\n    {\n      \"dialog_node\": \"string\",\n      \"description\": \"string\",\n      \"conditions\": \"string\",\n      \"parent\": \"string\",\n      \"previous_sibling\": \"string\",\n      \"output\": {\n        \"text\": \"string\"\n      },\n      \"context\": {},\n      \"metadata\": {},\n      \"go_to\": {\n        \"dialog_node\": \"string\",\n        \"selector\": \"string\",\n        \"return\": true\n      }\n    }\n  ],\n  \"entities\": [\n    {\n      \"entity\": \"string\",\n      \"description\": {\n        \"long\": [\n          \"string\"\n        ],\n        \"short\": [\n          \"string\"\n        ],\n        \"examples\": [\n          \"string\"\n        ]\n      },\n      \"type\": \"string\",\n      \"source\": \"string\",\n      \"open_list\": false,\n      \"values\": [\n        {\n          \"value\": \"string\",\n          \"metadata\": {},\n          \"synonyms\": [\n            \"string\"\n          ]\n        }\n      ]\n    }\n  ],\n  \"intents\": [\n    {\n      \"intent\": \"string\",\n      \"description\": \"string\",\n      \"examples\": [\n        {\n          \"text\": \"string\"\n        }\n      ]\n    }\n  ]\n }\n```\n *\n * Example Response:\n```json\n {\n  \"name\": \"Pizza app\",\n  \"created\": \"2015-12-06T23:53:59.153Z\",\n  \"language\": \"en\",\n  \"metadata\": {},\n  \"updated\": \"2015-12-06T23:53:59.153Z\",\n  \"description\": \"Pizza app\",\n  \"workspace_id\": \"pizza_app-e0f3\"\n }\n```\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} [params.name]\n * @param {String} [params.description]\n * @param {String} [params.language]\n * @param {Object} [params.metadata]\n * @param {Array<Object>} [params.entities]\n * @param {Array<Object>} [params.intents]\n * @param {Array<Object>} [params.dialog_nodes]\n * @param {Array<Object>} [params.counterexamples]\n * @param {Function} [callback]\n *\n */\n\nConversationV1.prototype.updateWorkspace = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}',\n      method: 'POST',\n      json: true,\n      body: pick(params, ['name', 'language', 'entities', 'intents', 'dialog_nodes', 'metadata', 'description', 'counterexamples']),\n      path: pick(params, ['workspace_id'])\n    },\n    requiredParams: ['workspace_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: workspaceStatus\n *\n * Returns the training status of the specified workspace\n *\n * Example Response:\n```json\n {\n  \"workspace_id\": \"pizza_app-e0f3\",\n  \"training\": \"true\"\n }\n```\n *\n * @param {Object} params\n * @param params.workspace_id\n * @param {Function} [callback]\n *\n */\n\nConversationV1.prototype.workspaceStatus = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/status',\n      method: 'GET',\n      json: true,\n      path: pick(params, ['workspace_id'])\n    },\n    requiredParams: ['workspace_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: createIntent\n *\n * Create a new intent\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} [params.intent]\n * @param {String} [params.description]\n * @param {Array<Object>} [params.examples]\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.createIntent = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents',\n      method: 'POST',\n      json: true,\n      path: pick(params, ['workspace_id']),\n      body: pick(params, ['intent', 'description', 'examples'])\n    },\n    requiredParams: ['workspace_id', 'intent'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: getIntents\n *\n * List the intents for a workspace.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {Boolean} [params.export=false] - if true, the full contents of all of the sub-resources are returned\n * @param {Number} [params.page_limit]\n * @param {Boolean} [params.include_count]\n * @param {String} [params.sort]\n * @param {String} [params.cursor]\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.getIntents = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents',\n      method: 'GET',\n      json: true,\n      path: pick(params, ['workspace_id']),\n      qs: pick(params, ['export', 'page_limit', 'include_count', 'sort', 'cursor'])\n    },\n    requiredParams: ['workspace_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: getIntent\n *\n * Get information about an intent, optionally including all intent content.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.intent\n * @param {Boolean} [params.export=false] - if true, the full contents of all of the sub-resources are returned\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.getIntent = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents/{intent}',\n      method: 'GET',\n      json: true,\n      path: pick(params, ['workspace_id', 'intent']),\n      qs: pick(params, ['export'])\n    },\n    requiredParams: ['workspace_id', 'intent'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: updateIntent\n *\n * Update an existing intent with new or modified data. You must provide JSON data defining the content of the updated intent.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.old_intent\n * @param {String} params.intent\n * @param {String} params.description\n * @param {Array<Object>} params.examples\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.updateIntent = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents/{old_intent}',\n      method: 'POST',\n      json: true,\n      path: pick(params, ['workspace_id', 'old_intent']),\n      body: pick(params, ['intent', 'description', 'examples'])\n    },\n    requiredParams: ['workspace_id', 'old_intent', 'intent'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: deleteIntent\n *\n * Delete an intent from a workspace\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.intent\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.deleteIntent = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents/{intent}',\n      method: 'DELETE',\n      json: true,\n      path: pick(params, ['workspace_id', 'intent'])\n    },\n    requiredParams: ['workspace_id', 'intent'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: getExamples\n *\n * List the user input examples for an intent.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.intent\n * @param {Number} [params.page_limit]\n * @param {Boolean} [params.include_count]\n * @param {String} [params.sort]\n * @param {String} [params.cursor]\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.getExamples = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents/{intent}/examples',\n      method: 'GET',\n      json: true,\n      path: pick(params, ['workspace_id', 'intent']),\n      qs: pick(params, ['page_limit', 'include_count', 'sort', 'cursor'])\n    },\n    requiredParams: ['workspace_id', 'intent'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: createExample\n *\n * Add a new user input example to an intent.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.intent\n * @param {String} params.text\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.createExample = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents/{intent}/examples',\n      method: 'POST',\n      json: true,\n      path: pick(params, ['workspace_id', 'intent']),\n      body: pick(params, ['text'])\n    },\n    requiredParams: ['workspace_id', 'intent'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: deleteExample\n *\n * Delete a user input example from an intent.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.intent\n * @param {String} params.text\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.deleteExample = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents/{intent}/examples/{text}',\n      method: 'DELETE',\n      json: true,\n      path: pick(params, ['workspace_id', 'intent', 'text'])\n    },\n    requiredParams: ['workspace_id', 'intent', 'text'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: getExample\n *\n * Get information about a user input example.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.intent\n * @param {String} params.text\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.getExample = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents/{intent}/examples/{text}',\n      method: 'GET',\n      json: true,\n      path: pick(params, ['workspace_id', 'intent', 'text'])\n    },\n    requiredParams: ['workspace_id', 'intent', 'text'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: updateExample\n *\n * Update the text of a user input example.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.intent\n * @param {String} params.text\n * @param {Object} params.example\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.updateExample = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/intents/{intent}/examples/{old_text}',\n      method: 'POST',\n      json: true,\n      path: pick(params, ['workspace_id', 'intent', 'old_text']),\n      body: pick(params, ['text'])\n    },\n    requiredParams: ['workspace_id', 'intent', 'old_text', 'text'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: getCounterExamples\n *\n * List the counterexamples for a workspace. Counterexamples are examples that have been marked as irrelevant input\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {Number} [params.page_limit]\n * @param {Boolean} [params.include_count]\n * @param {String} [params.sort]\n * @param {String} [params.cursor]\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.getCounterExamples = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/counterexamples',\n      method: 'GET',\n      json: true,\n      path: pick(params, ['workspace_id']),\n      qs: pick(params, ['page_limit', 'include_count', 'sort', 'cursor'])\n    },\n    requiredParams: ['workspace_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: createCounterExample\n *\n * Add a new counterexample to a workspace. Counterexamples are examples that have been marked as irrelevant input.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.text The text of a user input example.\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.createCounterExample = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/counterexamples',\n      method: 'POST',\n      json: true,\n      path: pick(params, ['workspace_id']),\n      body: pick(params, ['text'])\n    },\n    requiredParams: ['workspace_id', 'text'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: deleteCounterExample\n *\n * Delete a counterexample from a workspace. Counterexamples are examples that have been marked as irrelevant input.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.text The text of a user input example.\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.deleteCounterExample = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/counterexamples/{text}',\n      method: 'DELETE',\n      json: true,\n      path: pick(params, ['workspace_id', 'text'])\n    },\n    requiredParams: ['workspace_id', 'text'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: getCounterExample\n *\n * Get information about a counterexample. Counterexamples are examples that have been marked as irrelevant input.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.text The text of a user input example.\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.getCounterExample = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/counterexamples/{text}',\n      method: 'GET',\n      json: true,\n      path: pick(params, ['workspace_id', 'text'])\n    },\n    requiredParams: ['workspace_id', 'text'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Method: updateCounterExample\n *\n * Get information about a counterexample. Counterexamples are examples that have been marked as irrelevant input.\n *\n * @param {Object} params\n * @param {String} params.workspace_id\n * @param {String} params.old_text\n * @param {String} params.text The text of a user input example.\n * @param {Function} [callback]\n *\n */\nConversationV1.prototype.updateCounterExample = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/counterexamples/{old_text}',\n      method: 'POST',\n      json: true,\n      path: pick(params, ['workspace_id', 'old_text']),\n      body: pick(params, ['text'])\n    },\n    requiredParams: ['workspace_id', 'old_text', 'text'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = ConversationV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/conversation/v1-experimental.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst pick = require('object.pick');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction ConversationV1Experimental(options) {\n  BaseService.call(this, options);\n\n  if (!this._options.silent) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      new Error('Watson Conversation v1-experimental is sunset as of 2016-08-01. Please upgrade to v1. Set {silent: true} to disable this message.').stack\n    );\n  }\n\n  // Check if 'version_date' was provided\n  if (typeof this._options.version_date === 'undefined') {\n    throw new Error('Argument error: version_date was not specified, use 2016-05-19');\n  }\n  this._options.qs.version = options.version_date;\n}\nutil.inherits(ConversationV1Experimental, BaseService);\nConversationV1Experimental.prototype.name = 'conversation';\nConversationV1Experimental.prototype.version = 'v1-experimental';\nConversationV1Experimental.URL = 'https://gateway.watsonplatform.net/conversation-experimental/api';\n\n/**\n * Returns a response to a user utterance.\n * @param  {Object}   params   { workspace_id: '',  }\n */\nConversationV1Experimental.prototype.message = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/workspaces/{workspace_id}/message',\n      method: 'POST',\n      json: true,\n      body: pick(params, ['input', 'context']),\n      path: pick(params, ['workspace_id'])\n    },\n    requiredParams: ['workspace_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = ConversationV1Experimental;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/dialog/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst extend = require('extend');\nconst requestFactory = require('../lib/requestwrapper');\nconst pick = require('object.pick');\nconst omit = require('object.omit');\nconst isStream = require('isstream');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction DialogV1(options) {\n  BaseService.call(this, options);\n\n  if (!options.silent) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'WARNING: The Dialog service was deprecated, existing instances of the service will continue to function until August 9, 2017. See https://www.ibm.com/watson/developercloud/doc/conversation/migration.shtml. Set {silent: true} to disable this message.'\n    );\n  }\n}\nutil.inherits(DialogV1, BaseService);\nDialogV1.prototype.name = 'dialog';\nDialogV1.prototype.version = 'v1';\nDialogV1.URL = 'https://gateway.watsonplatform.net/dialog/api';\n\n/**\n * Retrieves the values for profile variables for specific client ID\n * @param  {Object}   params   { client_id: '', dialog_id: '', name:''}\n */\nDialogV1.prototype.getProfile = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/dialogs/{dialog_id}/profile',\n      method: 'GET',\n      json: true,\n      path: params,\n      qs: pick(params, ['client_id', 'name'])\n    },\n    requiredParams: ['dialog_id', 'client_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Sets the values for profile variables\n * @param  {Object}   params   { client_id: '', dialog_id: '', name_values:''}\n */\nDialogV1.prototype.updateProfile = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/dialogs/{dialog_id}/profile',\n      method: 'PUT',\n      json: true,\n      body: pick(params, ['name_values', 'client_id']),\n      path: params\n    },\n    requiredParams: ['dialog_id', 'name_values'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns a chat session data dump for a given date.\n * @param  {Object}   params   { client_id: '', dialog_id: '', name_values:''}\n */\nDialogV1.prototype.getConversation = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/dialogs/{dialog_id}/conversation',\n      method: 'GET',\n      json: true,\n      qs: omit(params, ['dialog_id']),\n      path: params\n    },\n    requiredParams: ['dialog_id', 'date_from', 'date_to'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns a response for a submitted input message.\n * Also used to start new conversations.\n * @param  {Object}   params   { client_id: '', dialog_id: '' }\n */\nDialogV1.prototype.conversation = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/dialogs/{dialog_id}/conversation',\n      method: 'POST',\n      json: true,\n      form: omit(params, ['dialog_id']),\n      path: params\n    },\n    requiredParams: ['dialog_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Updates content for specified nodes.\n * @param  {Object}   params   { dialog_id: '' }\n */\nDialogV1.prototype.updateContent = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/dialogs/{dialog_id}/content',\n      method: 'PUT',\n      json: true,\n      path: params\n    },\n    requiredParams: ['dialog_id'],\n    defaultOptions: extend(true, {}, this._options, pick(params, ['headers']))\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Gets content for nodes.\n * @param  {Object}   params   { dialog_id: '' }\n */\nDialogV1.prototype.getContent = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/dialogs/{dialog_id}/content',\n      method: 'GET',\n      json: true,\n      path: params\n    },\n    requiredParams: ['dialog_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Create a dialog based on a file and name\n * @param  {Object}   params   { name: '', file:'' }\n */\nDialogV1.prototype.createDialog = function(params, callback) {\n  params = params || {};\n\n  if (!params.file) {\n    callback(new Error('Missing required parameters: file'));\n    return;\n  }\n\n  if (!isStream(params.file)) {\n    callback(new Error('file is not a standard Node.js Stream'));\n    return;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/dialogs',\n      method: 'POST',\n      json: true,\n      formData: pick(params, ['name', 'file'])\n    },\n    requiredParams: ['name'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns the dialogs associated with a service instance\n */\nDialogV1.prototype.getDialogs = function(params, callback) {\n  const parameters = {\n    options: {\n      url: '/v1/dialogs',\n      method: 'GET',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Delete a dialog and removes all associated data\n */\nDialogV1.prototype.deleteDialog = function(params, callback) {\n  const parameters = {\n    options: {\n      url: '/v1/dialogs/{dialog_id}',\n      method: 'DELETE',\n      json: true,\n      path: params\n    },\n    requiredParams: ['dialog_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Update a dialog with a new dialog file\n * @param  {Object}   params   { dialog_id: '' }\n */\nDialogV1.prototype.updateDialog = function(params, callback) {\n  params = params || {};\n\n  if (!params.file) {\n    callback(new Error('Missing required parameters: file'));\n    return;\n  }\n\n  if (!isStream(params.file)) {\n    callback(new Error('file is not a standard Node.js Stream'));\n    return;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/dialogs/{dialog_id}',\n      method: 'PUT',\n      json: true,\n      path: params,\n      formData: omit(params, ['dialog_id'])\n    },\n    requiredParams: ['dialog_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = DialogV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/discovery/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst requestFactory = require('../lib/requestwrapper');\nconst BaseService = require('../lib/base_service');\nconst pick = require('object.pick');\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction DiscoveryV1(options) {\n  BaseService.call(this, options);\n\n  // Check if 'version_date' was provided\n  if (typeof this._options.version_date === 'undefined') {\n    throw new Error('Argument error: version_date was not specified, use DiscoveryV1.VERSION_DATE_2016_12_15');\n  }\n  this._options.qs.version = options.version_date;\n}\n\nutil.inherits(DiscoveryV1, BaseService);\nDiscoveryV1.prototype.name = 'discovery';\nDiscoveryV1.prototype.version = 'v1';\nDiscoveryV1.URL = 'https://gateway.watsonplatform.net/discovery/api';\n\n/**\n * Initial release\n * @type {string}\n */\nDiscoveryV1.VERSION_DATE_2016_12_15 = '2016-12-15';\n\n/**\n * Return the list of environments\n *\n * @param {Object} params\n */\nDiscoveryV1.prototype.getEnvironments = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments',\n      method: 'GET',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Create a new environment\n * @param {string} name\n * @param {string} description\n * @param {int} size (optional)\n */\nDiscoveryV1.prototype.createEnvironment = function(params, callback) {\n  params = params || {};\n\n  // size is an int of 1,2,3, default 1\n  if (!params.size) {\n    params.size = 1;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/environments',\n      method: 'POST',\n      multipart: [\n        {\n          'content-type': 'application/json',\n          body: JSON.stringify(pick(params, ['name', 'description', 'size']))\n        }\n      ],\n      json: true\n    },\n    originalParams: params,\n    requiredParams: ['name', 'description'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get details about an environment\n *\n * @param {Object} params\n * @param {String} params.environment_id\n */\nDiscoveryV1.prototype.getEnvironment = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}',\n      method: 'GET',\n      path: pick(params, ['environment_id']),\n      json: true\n    },\n    requiredParams: ['environment_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get details about an environment\n *\n * @param {Object} params\n * @param {String} params.environment_id\n */\nDiscoveryV1.prototype.deleteEnvironment = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}',\n      method: 'DELETE',\n      path: pick(params, ['environment_id']),\n      json: true\n    },\n    requiredParams: ['environment_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * List all configurations\n *\n * @param {Object} params\n * @param {String} params.environment_id\n */\nDiscoveryV1.prototype.getConfigurations = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/configurations',\n      method: 'GET',\n      path: pick(params, ['environment_id']),\n      json: true\n    },\n    requiredParams: ['environment_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get details about a configuration\n *\n * @param {Object} params\n * @param {String} params.environment_id\n * @param {String} params.configuration_id\n */\nDiscoveryV1.prototype.getConfiguration = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/configurations/{configuration_id}',\n      method: 'GET',\n      path: pick(params, ['environment_id', 'configuration_id']),\n      json: true\n    },\n    requiredParams: ['environment_id', 'configuration_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Return the list of collections in the given environment\n *\n * @param {Object} params\n * @param {String} params.environment_id\n  */\nDiscoveryV1.prototype.getCollections = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections',\n      method: 'GET',\n      path: pick(params, ['environment_id']),\n      json: true\n    },\n    requiredParams: ['environment_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get details about a collection\n *\n * @param {Object} params\n * @param {String} params.environment_id\n * @param {string} params.collection_id\n */\nDiscoveryV1.prototype.getCollection = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections/{collection_id}',\n      method: 'GET',\n      path: pick(params, ['environment_id', 'collection_id']),\n      json: true\n    },\n    requiredParams: ['environment_id', 'collection_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Create a new collection\n *\n * @param {Object} params\n * @param {String} params.environment_id environment guid for the collection\n * @param {string} params.collection_name\n * @param {string} params.description\n * @param {string} params.configuration_id  configuration to create the collection in\n * @param {string} params.language_code currently, only `en_us` is supported\n */\nDiscoveryV1.prototype.createCollection = function(params, callback) {\n  params = params || {};\n\n  params.language_code = params.language_code || 'en_us';\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections',\n      method: 'POST',\n      path: pick(params, ['environment_id']),\n      multipart: [\n        {\n          'content-type': 'application/json',\n          body: JSON.stringify(pick(params, ['collection_name', 'description', 'configuration_id', 'language_code']))\n        }\n      ],\n      json: true\n    },\n    originalParams: params,\n    requiredParams: ['environment_id', 'configuration_id', 'collection_name'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Delete a collection\n *\n * @param {Object} params\n * @param {String} params.environment_id environment guid for the collection\n * @param {string} params.collection_id the guid of the collection to delete\n */\nDiscoveryV1.prototype.deleteCollection = function(params, callback) {\n  params = params || {};\n\n  params.language_code = params.language_code || 'en_us';\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections/{collection_id}',\n      method: 'DELETE',\n      path: pick(params, ['environment_id', 'collection_id']),\n      json: true\n    },\n    requiredParams: ['environment_id', 'collection_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Add a document to a collection\n * @param params\n * @param {String} params.environment_id environment guid for the collection\n * @param {string} params.collection_id the guid of the collection to delete\n * @param {Buffer|ReadableStream|Object} params.file a file to post (smaller than 50mb)\n * @param {string} [params.configuration_id] config guid\n * @param {string} [params.metadata] file metadata, including content-type (will infer if missing)\n * @param callback\n * @return {ReadableStream|undefined}\n */\nDiscoveryV1.prototype.addDocument = function(params, callback) {\n  params = params || {};\n\n  const queryParams = pick(params, ['configuration_id']);\n  const formDataParams = pick(params, ['file', 'metadata']);\n\n  // if we get a buffer or object, we need to include stuff about filename for the service\n  if (formDataParams.file) {\n    if (\n      typeof formDataParams.file.filename !== 'string' &&\n      !(formDataParams.file.options && typeof formDataParams.file.options.filename !== 'string') &&\n      !(formDataParams.file.path && typeof formDataParams.file.path !== 'string') &&\n      !(formDataParams.file.name && typeof formDataParams.file.name !== 'string')\n    ) {\n      const filedat = formDataParams.file;\n      // the filename used below is because the name must exist\n      formDataParams.file = { value: filedat, options: { filename: '_' } };\n    }\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections/{collection_id}/documents',\n      method: 'POST',\n      path: pick(params, ['environment_id', 'collection_id']),\n      qs: queryParams,\n      formData: formDataParams,\n      json: true\n    },\n    requiredParams: ['environment_id', 'collection_id', 'file'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Update or partially update a document to create or replace an existing document\n * @param params\n * @param {String} params.environment_id environment guid for the collection\n * @param {string} params.collection_id the guid of the collection\n * @param {string} params.document_id the guid of the document to update\n * @param {Buffer|ReadableStream|Object} params.file a file to post (smaller than 50mb)\n * @param {string} [params.configuration_id] config guid\n * @param {string} [params.metadata] file metadata, including content-type (will infer if missing)\n * @param callback\n * @return {ReadableStream|undefined}\n */\nDiscoveryV1.prototype.updateDocument = function(params, callback) {\n  params = params || {};\n\n  const queryParams = pick(params, ['configuration_id']);\n  const formDataParams = pick(params, ['file', 'metadata']);\n\n  // if we get a buffer or object, we need to include stuff about filename for the service\n  if (formDataParams.file) {\n    if (\n      typeof formDataParams.file.filename !== 'string' &&\n      !(formDataParams.file.options && typeof formDataParams.file.options.filename !== 'string') &&\n      !(formDataParams.file.path && typeof formDataParams.file.path !== 'string') &&\n      !(formDataParams.file.name && typeof formDataParams.file.name !== 'string')\n    ) {\n      const filedat = formDataParams.file;\n      // the filename used below is because the name must exist\n      formDataParams.file = { value: filedat, options: { filename: '_' } };\n    }\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections/{collection_id}/documents/{document_id}',\n      method: 'POST',\n      path: pick(params, ['environment_id', 'collection_id', 'document_id']),\n      qs: queryParams,\n      formData: formDataParams,\n      json: true\n    },\n    requiredParams: ['environment_id', 'collection_id', 'document_id', 'file'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Delete a specific document\n * @param params\n * @param {String} params.environment_id environment guid for the collection\n * @param {string} params.collection_id the guid of the collection to delete\n * @param {string} params.document_id the guid of the document to delete\n * @param callback\n * @return {ReadableStream|undefined}\n */\nDiscoveryV1.prototype.deleteDocument = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections/{collection_id}/documents/{document_id}',\n      method: 'DELETE',\n      path: pick(params, ['environment_id', 'collection_id', 'document_id']),\n      json: true\n    },\n    requiredParams: ['environment_id', 'collection_id', 'document_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Queries the collection\n *\n * @param {Object} params\n * @param {String} params.environment_id\n * @param {string} params.collection_id\n * @param {String} [params.filter]  A cacheable query that allows you to limit the information returned to exclude anything that isn't related to what you are searching. Filter searches are better for metadata type searches and when you are trying to get a sense of concepts in the dataset.\n * @param {String} [params.query]  A query search returns all possible results, even when it's not very relevant, with the most relevant documents listed first. Use a query search when you want to find the most relevant search results. Results are scored between 0 and 1, with 1 being an exact match and 0 being not a match at all.\n * @param {String} [params.aggregation] An aggregation search uses combinations of filters and query search to return an exact answer. Aggregations are useful for building applications, because you can use them to build lists, tables, and time series. For a full list of possible aggregrations, see the Query reference.\n * @param {Number} [params.count=10] Number of documents to return\n * @param {String} [params.return] A comma separated list of the portion of the document hierarchy to return.\n * @param {Number} [params.offset=0] For pagination purposes. Returns additional pages of results. Deep pagination is highly unperformant, and should be avoided.\n */\nDiscoveryV1.prototype.query = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections/{collection_id}/query',\n      method: 'GET',\n      json: true,\n      path: pick(params, ['environment_id', 'collection_id']),\n      qs: pick(params, ['filter', 'aggregation', 'return', 'count', 'offset', 'query'])\n    },\n    requiredParams: ['environment_id', 'collection_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = DiscoveryV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/discovery/v1-experimental.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst requestFactory = require('../lib/requestwrapper');\nconst BaseService = require('../lib/base_service');\nconst pick = require('object.pick');\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction DiscoveryV1Experimental(options) {\n  BaseService.call(this, options);\n\n  // Check if 'version_date' was provided\n  if (typeof this._options.version_date === 'undefined') {\n    throw new Error('Argument error: version_date was not specified, use DiscoveryV1Experimental.VERSION_DATE_2016_07_11');\n  }\n  this._options.qs.version = options.version_date;\n}\n\nutil.inherits(DiscoveryV1Experimental, BaseService);\nDiscoveryV1Experimental.prototype.name = 'discovery';\nDiscoveryV1Experimental.prototype.version = 'v1-experimental';\nDiscoveryV1Experimental.URL = 'https://gateway.watsonplatform.net/discovery-experimental/api';\n\n/**\n * Initial release\n * @type {string}\n */\nDiscoveryV1Experimental.VERSION_DATE_2016_07_11 = '2016-11-07';\n\n/**\n * Return the list of environments\n *\n * @param {Object} params\n * @param {String} [params.name] search enviroments with the given name\n */\nDiscoveryV1Experimental.prototype.getEnvironments = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments',\n      method: 'GET',\n      json: true,\n      qs: pick(params, ['name'])\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get details about an environment\n *\n * @param {Object} params\n * @param {String} params.environment_id\n */\nDiscoveryV1Experimental.prototype.getEnvironment = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}',\n      method: 'GET',\n      path: pick(params, ['environment_id']),\n      json: true\n    },\n    requiredParams: ['environment_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Return the list of collections in the given environment\n *\n * @param {Object} params\n * @param {String} params.environment_id\n * @param {String} [params.name] Find collections with the given name.\n */\nDiscoveryV1Experimental.prototype.getCollections = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections',\n      method: 'GET',\n      path: pick(params, ['environment_id']),\n      json: true\n    },\n    requiredParams: ['environment_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get details about a collection\n *\n * @param {Object} params\n * @param {String} params.environment_id\n * @param {string} params.collection_id\n */\nDiscoveryV1Experimental.prototype.getCollection = function(params, collectionId, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections/{collection_id}',\n      method: 'GET',\n      path: pick(params, ['environment_id', 'collection_id']),\n      json: true\n    },\n    requiredParams: ['environment_id', 'collection_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Queries the collection\n *\n * @param {Object} params\n * @param {String} params.environment_id\n * @param {string} params.collection_id\n * @param {String} [params.filter]  A cacheable query that allows you to limit the information returned to exclude anything that isn't related to what you are searching. Filter searches are better for metadata type searches and when you are trying to get a sense of concepts in the dataset.\n * @param {String} [params.query]  A query search returns all possible results, even when it's not very relevant, with the most relevant documents listed first. Use a query search when you want to find the most relevant search results. Results are scored between 0 and 1, with 1 being an exact match and 0 being not a match at all.\n * @param {String} [params.aggregation] An aggregation search uses combinations of filters and query search to return an exact answer. Aggregations are useful for building applications, because you can use them to build lists, tables, and time series. For a full list of possible aggregrations, see the Query reference.\n * @param {Number} [params.count=10] Number of documents to return\n * @param {String} [params.return] A comma separated list of the portion of the document hierarchy to return.\n * @param {Number} [params.offset=0] For pagination purposes. Returns additional pages of results. Deep pagination is highly unperformant, and should be avoided.\n */\nDiscoveryV1Experimental.prototype.query = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/environments/{environment_id}/collections/{collection_id}/query',\n      method: 'GET',\n      json: true,\n      path: pick(params, ['environment_id', 'collection_id']),\n      qs: pick(params, ['filter', 'aggregation', 'return', 'count', 'offset', 'query'])\n    },\n    requiredParams: ['environment_id', 'collection_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = DiscoveryV1Experimental;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/document-conversion/v1.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst isStream = require('isstream');\nconst omit = require('object.omit');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n * Document Conversion service\n * @param {Object} options\n * @constructor\n */\nfunction DocumentConversionV1(options) {\n  BaseService.call(this, options);\n\n  // Warn if not specifying version date\n  if (!this._options.version_date && !this._options.silent) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      '[DocumentConversion] WARNING: No version_date specified. Using a (possibly old) default. ' +\n        'e.g. watson.document_conversion({ version_date: \"2015-12-15\" })'\n    );\n  }\n}\nutil.inherits(DocumentConversionV1, BaseService);\nDocumentConversionV1.prototype.name = 'document_conversion';\nDocumentConversionV1.prototype.version = 'v1';\nDocumentConversionV1.URL = 'https://gateway.watsonplatform.net/document-conversion/api';\nDocumentConversionV1.prototype.serviceDefaults = {\n  qs: { version: '2015-12-15' }\n};\n\nDocumentConversionV1.prototype.conversion_target = {\n  ANSWER_UNITS: 'answer_units',\n  NORMALIZED_HTML: 'normalized_html',\n  NORMALIZED_TEXT: 'normalized_text'\n};\n\n/**\n * This sets up the content type \"headers\" in the form/multipart body (not in the actual headers)\n * @private\n * @param params\n */\nfunction fixupContentType(params) {\n  if (params.content_type) {\n    params.file = {\n      value: params.file,\n      options: {\n        contentType: params.content_type\n      }\n    };\n  }\n}\n\n/**\n * One-off convert an attached document OR convert a previously uploaded document by ID\n *\n * To convert a previously uploaded document, set params.document_id\n *\n * @param  {Object} params\n * @param  {Object} params.conversion_target Must be set to one of ['answer_units', 'normalized_html', 'normalized_text']\n * @param  {ReadableStream} [params.file] The document file to convert. May be a ReadableStream or Buffer\n * @param  {String} [params.content_type] Set this when the content type cannot be determined from the filename (params.file.path)\n * @param  {Object} [params.config] Optional configuration option. Recommended way to set configuration.\n * @param  {Function} callback\n */\nDocumentConversionV1.prototype.convert = function(params, callback) {\n  params = params || {};\n  if (typeof params.conversion_target === 'string') {\n    params.conversion_target = params.conversion_target.toLowerCase();\n  }\n  const keys = Object.keys(DocumentConversionV1.prototype.conversion_target);\n  const values = keys.map(function(v) {\n    return DocumentConversionV1.prototype.conversion_target[v];\n  });\n  if (values.indexOf(params.conversion_target) === -1) {\n    callback(new Error('Missing required parameters: conversion_target. Possible values are: ' + values.join(', ')));\n    return;\n  }\n\n  if (!params.file && !params.document_id) {\n    callback(new Error('Missing required parameters: either params.file or params.document_id must be specified'));\n    return;\n  }\n\n  if (params.file && !isStream(params.file) && !Buffer.isBuffer(params.file) && !params.file.value) {\n    callback(new Error('Missing required parameters: file is not a standard Node.js Stream or Buffer'));\n    return;\n  }\n\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v1/convert_document',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  // send the parameters in the body or as formData depending on the request\n  if (params.file) {\n    fixupContentType(params);\n    parameters.options.formData = {\n      file: params.file,\n      config: {\n        value: JSON.stringify(params.config || omit(params, ['file', 'content_type'])),\n        options: {\n          contentType: 'application/json; charset=utf-8'\n        }\n      }\n    };\n  } else {\n    parameters.options.body = params;\n  }\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * One-off convert and index a document via index_document API\n *\n * NOTE: A SOLR cluster and search collection will have to be created through the Retrieve and Rank\n *       service prior to using this API if actual indexing is performed (dry_run=false).\n *\n * @param  {Object} params\n * @param  {ReadableStream} [params.file] The document file to convert. May be a ReadableStream or Buffer\n * @param  {Object} params.metadata Metadata array of Object's where each object contains 'name' and 'value'\n * @param  {Object} params.config Configuration for the conversion and indexing. The conversion config needs\n                      to be in a 'convert_document' object. This can include configuration for 'pdf', 'word'\n                      and 'normalized_html' phases of the conversion process. The indexing config needs to be\n                      in a 'retrieve_and_rank' object. The 'retrieve_and_rank' object has the following fields:\n                      'dry_run' - boolean value, true if a dry run is to be performed, false to actually index,\n                      'service_instance_id' - The serviceGuid of your instance of the retrieve and rank\n                      service (required if dry_run=false), 'cluster_id' - The Solr cluster id for your retrieve\n                      and rank service instance (required if dry_run=false), 'search_collection' - The name of\n                      your Solr search collection from your retrieve and rank service instance (required if\n                      dry_run=false), and 'fields' - Configuration information for field 'mappings', fields\n                      to 'include', and fields to 'exclude' during indexing (exclude takes precedence over include)\n * @param  {Function} callback\n */\nDocumentConversionV1.prototype.index = function(params, callback) {\n  params = params || {};\n  if (!params.file && !params.metadata) {\n    callback(new Error('Missing required parameters: file or metadata. At least one of those is required.'));\n    return;\n  }\n  if (params.file && !isStream(params.file) && !Buffer.isBuffer(params.file) && !params.file.value) {\n    callback(new Error('Missing required parameters: file is not a standard Node.js Stream or Buffer'));\n    return;\n  }\n  if (!params.config) {\n    callback(new Error('Missing required parameters: file or metadata. At least one of those is required.'));\n    return;\n  }\n\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v1/index_document',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  // send the parameters as formData\n  if (params.file && params.metadata) {\n    fixupContentType(params);\n    parameters.options.formData = {\n      file: params.file,\n      config: {\n        value: JSON.stringify(params.config),\n        options: {\n          contentType: 'application/json; charset=utf-8'\n        }\n      },\n      metadata: {\n        value: JSON.stringify(params.metadata),\n        options: {\n          contentType: 'application/json; charset=utf-8'\n        }\n      }\n    };\n  } else if (params.file) {\n    fixupContentType(params);\n    parameters.options.formData = {\n      file: params.file,\n      config: {\n        value: JSON.stringify(params.config),\n        options: {\n          contentType: 'application/json; charset=utf-8'\n        }\n      }\n    };\n  } else if (params.metadata) {\n    parameters.options.formData = {\n      config: {\n        value: JSON.stringify(params.config),\n        options: {\n          contentType: 'application/json; charset=utf-8'\n        }\n      },\n      metadata: {\n        value: JSON.stringify(params.metadata),\n        options: {\n          contentType: 'application/json; charset=utf-8'\n        }\n      }\n    };\n  } else {\n    callback(new Error('Missing required parameters: file or metadata. At least one of those is required.'));\n    return;\n  }\n\n  return requestFactory(parameters, callback);\n};\n\n// give a clear error message for the deprecated methods\n[\n  'getOutput',\n  'getOutputs',\n  'getJobLog',\n  'getJobs',\n  'getJob',\n  'createJob',\n  'getBatchDocument',\n  'getBatchDocuments',\n  'addDocumentToBatch',\n  'getDocument',\n  'getDocuments',\n  'uploadDocument',\n  'getBatchDocuments',\n  'updateBatch',\n  'getBatch',\n  'createBatch',\n  'getBatches'\n].forEach(function(name) {\n  DocumentConversionV1.prototype[name] = function deprecated() {\n    throw new Error('The DocumentConversion.' + name + '() method was deprecated and is no longer available, please use convert() instead.');\n  };\n});\n\nmodule.exports = DocumentConversionV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/language-translation/v2.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst extend = require('extend');\nconst pick = require('object.pick');\nconst isStream = require('isstream');\nconst helper = require('../lib/helper');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {string} [params.url=https://gateway.watsonplatform.net/language-translation/api] The service URL.\n * @param {string} params.username Username\n * @param {string} params.password Password\n * @constructor\n */\nfunction LanguageTranslationV2(options) {\n  BaseService.call(this, options);\n}\nutil.inherits(LanguageTranslationV2, BaseService);\nLanguageTranslationV2.prototype.name = 'language_translation';\nLanguageTranslationV2.prototype.version = 'v2';\nLanguageTranslationV2.URL = 'https://gateway.watsonplatform.net/language-translation/api';\n\n/**\n * Return the translation models\n */\n\n/**\n * Return the translation models\n * @param  {string}   params.default   Query filters to check if the model is\n *                            the default one used when only source\n *                            and target languages are specified.\n * @param  {string}   params.source   Filter by source language\n * @param  {string}   params.target   Filter by target language\n */\nLanguageTranslationV2.prototype.getModels = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v2/models',\n      qs: pick(params, ['default', 'source', 'target']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Return the translation model\n * @param  {string}   params.model_id   The model identifier\n */\nLanguageTranslationV2.prototype.getModel = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v2/models/{model_id}',\n      path: pick(params, ['model_id']),\n      json: true\n    },\n    requiredParams: ['model_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Creates a translation model\n * @param  {string}   params.base_model_id   The base model identifier\n * @param  {string}   params.name   The model name\n * @param  {stream}   params.forced_glossary   A UTF-8 encoded TMX file that contains pairs of matching terms in the source and target language that are seen as absolute by the system. This file completely overwrites the original domain data.\n * @param  {stream}   params.parallel_corpus   A UTF-8 encoded TMX file that contains matching phrases in the source and target language that serve as examples for Watson. Parallel corpora differ from glossaries because they do not overwrite the original domain data.\n * @param  {stream}   params.monolingual_corpus A UTF-8 encoded plain text file that contains a body of text in the target language that is related to what you are translating. A monolingual corpus helps improve literal translations to be more fluent and human.\n */\n\nLanguageTranslationV2.prototype.createModel = function(params, callback) {\n  params = params || {};\n\n  const missingParams = helper.getMissingParams(params, ['base_model_id']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n\n  const inputTypes = ['forced_glossary', 'parallel_corpus', 'monolingual_corpus'];\n\n  for (const type in inputTypes) {\n    if (inputTypes.hasOwnProperty(type)) {\n      if (params[inputTypes[type]] && !isStream(params[inputTypes[type]])) {\n        callback(new Error(inputTypes[type] + ' is not a standard Node.js Stream'));\n        return;\n      }\n    }\n  }\n\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v2/models',\n      qs: pick(params, ['name', 'base_model_id']),\n      formData: pick(params, inputTypes),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Deletes a model\n * @param  {string}   params.model_id   The model identifier\n */\nLanguageTranslationV2.prototype.deleteModel = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      method: 'DELETE',\n      url: '/v2/models/{model_id}',\n      path: pick(params, ['model_id']),\n      json: true\n    },\n    requiredParams: ['model_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Translate pharagraphs from one language into another\n * @param {string} params.source Source language\n * @param {string} params.target Target language\n */\nLanguageTranslationV2.prototype.translate = function(params, callback) {\n  params = params || {};\n\n  if (!(params.model_id || params.source && params.target)) {\n    callback(new Error('Missing required parameters: model_id or source and target'));\n    return;\n  }\n  const parameters = {\n    options: {\n      url: '/v2/translate',\n      method: 'POST',\n      json: true,\n      body: pick(params, ['source', 'target', 'text', 'model_id'])\n    },\n    requiredParams: ['text'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns the identifiable languages\n */\nLanguageTranslationV2.prototype.getIdentifiableLanguages = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v2/identifiable_languages',\n      method: 'GET'\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Identify the text based on the identifiable languages\n * @param  {string} params.text  text to identify\n */\nLanguageTranslationV2.prototype.identify = function(params, callback) {\n  if (!params || !params.text) {\n    callback(new Error('Missing required parameters: text'));\n    return;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v2/identify',\n      method: 'POST',\n      body: params.text\n    },\n    defaultOptions: extend(true, {}, this._options, {\n      headers: {\n        accept: 'application/json',\n        'content-type': 'text/plain'\n      }\n    })\n  };\n\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = LanguageTranslationV2;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/language-translator/v2.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst extend = require('extend');\nconst pick = require('object.pick');\nconst isStream = require('isstream');\nconst helper = require('../lib/helper');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {string} [params.url=https://gateway.watsonplatform.net/language-translation/api] The service URL.\n * @param {string} params.username Username\n * @param {string} params.password Password\n * @constructor\n */\nfunction LanguageTranslatorV2(options) {\n  // Welp, this is awkward. Originally the rename was *just* a rename, but then (after the SDK was updated,\n  // but before the backend was updated), it was decided that the billing should be simplified at the same time.\n  // That's a solid improvement, but it means that the SDK now needs to support both services independently,\n  // and correcting the default URL here will break older code, so it must be reserved for a major release.\n  // todo: consider checking for options.url === LanguageTranslationV2.URL and also throw this warning then.\n  // (This probably does't matter since the api didn't change)\n  if (!options.url) {\n    const err = new Error(\n      'LanguageTranslatorV2 currently defaults to the url for LanguageTranslationV2, ' +\n        'but this will change in the next major release of the watson-developer-cloud Node.js SDK. ' +\n        'Please either specify the url https://gateway.watsonplatform.net/language-translator/api or else use ' +\n        'LanguageTranslationV2. ' +\n        'See http://www.ibm.com/watson/developercloud/doc/language-translator/migrating.shtml for more details.'\n    );\n    // eslint-disable-next-line no-console\n    console.warn(err);\n  }\n\n  BaseService.call(this, options);\n}\nutil.inherits(LanguageTranslatorV2, BaseService);\nLanguageTranslatorV2.prototype.name = 'language_translator';\nLanguageTranslatorV2.prototype.version = 'v2';\nLanguageTranslatorV2.URL = 'https://gateway.watsonplatform.net/language-translation/api'; // This is incorrect and will change in v 3.0.0\n/**\n * Return the translation models\n */\n\n/**\n * Return the translation models\n * @param  {string}   params.default   Query filters to check if the model is\n *                            the default one used when only source\n *                            and target languages are specified.\n * @param  {string}   params.source   Filter by source language\n * @param  {string}   params.target   Filter by target language\n */\nLanguageTranslatorV2.prototype.getModels = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v2/models',\n      qs: pick(params, ['default', 'source', 'target']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Return the translation model\n * @param  {string}   params.model_id   The model identifier\n */\nLanguageTranslatorV2.prototype.getModel = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v2/models/{model_id}',\n      path: pick(params, ['model_id']),\n      json: true\n    },\n    requiredParams: ['model_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Creates a translation model\n * @param  {string}   params.base_model_id   The base model identifier\n * @param  {string}   params.name   The model name\n * @param  {stream}   params.forced_glossary   A UTF-8 encoded TMX file that contains pairs of matching terms in the source and target language that are seen as absolute by the system. This file completely overwrites the original domain data.\n * @param  {stream}   params.parallel_corpus   A UTF-8 encoded TMX file that contains matching phrases in the source and target language that serve as examples for Watson. Parallel corpora differ from glossaries because they do not overwrite the original domain data.\n * @param  {stream}   params.monolingual_corpus A UTF-8 encoded plain text file that contains a body of text in the target language that is related to what you are translating. A monolingual corpus helps improve literal translations to be more fluent and human.\n */\n\nLanguageTranslatorV2.prototype.createModel = function(params, callback) {\n  params = params || {};\n\n  const missingParams = helper.getMissingParams(params, ['base_model_id']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n\n  const inputTypes = ['forced_glossary', 'parallel_corpus', 'monolingual_corpus'];\n\n  for (const type in inputTypes) {\n    if (inputTypes.hasOwnProperty(type)) {\n      if (params[inputTypes[type]] && !isStream(params[inputTypes[type]])) {\n        callback(new Error(inputTypes[type] + ' is not a standard Node.js Stream'));\n        return;\n      }\n    }\n  }\n\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v2/models',\n      qs: pick(params, ['name', 'base_model_id']),\n      formData: pick(params, inputTypes),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Deletes a model\n * @param  {string}   params.model_id   The model identifier\n */\nLanguageTranslatorV2.prototype.deleteModel = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      method: 'DELETE',\n      url: '/v2/models/{model_id}',\n      path: pick(params, ['model_id']),\n      json: true\n    },\n    requiredParams: ['model_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Translate pharagraphs from one language into another\n * @param {string} params.source Source language\n * @param {string} params.target Target language\n */\nLanguageTranslatorV2.prototype.translate = function(params, callback) {\n  params = params || {};\n\n  if (!(params.model_id || params.source && params.target)) {\n    callback(new Error('Missing required parameters: model_id or source and target'));\n    return;\n  }\n  const parameters = {\n    options: {\n      url: '/v2/translate',\n      method: 'POST',\n      json: true,\n      body: pick(params, ['source', 'target', 'text', 'model_id'])\n    },\n    requiredParams: ['text'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns the identifiable languages\n */\nLanguageTranslatorV2.prototype.getIdentifiableLanguages = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v2/identifiable_languages',\n      method: 'GET'\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Identify the text based on the identifiable languages\n * @param  {string} params.text  text to identify\n */\nLanguageTranslatorV2.prototype.identify = function(params, callback) {\n  if (!params || !params.text) {\n    callback(new Error('Missing required parameters: text'));\n    return;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v2/identify',\n      method: 'POST',\n      body: params.text\n    },\n    defaultOptions: extend(true, {}, this._options, {\n      headers: {\n        accept: 'application/json',\n        'content-type': 'text/plain'\n      }\n    })\n  };\n\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = LanguageTranslatorV2;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/natural-language-classifier/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst pick = require('object.pick');\nconst omit = require('object.omit');\nconst isStream = require('isstream');\nconst toCSV = require('./json-training-to-csv');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction NaturalLanguageClassifierV1(options) {\n  BaseService.call(this, options);\n}\nutil.inherits(NaturalLanguageClassifierV1, BaseService);\nNaturalLanguageClassifierV1.prototype.name = 'natural_language_classifier';\nNaturalLanguageClassifierV1.prototype.version = 'v1';\nNaturalLanguageClassifierV1.URL = 'https://gateway.watsonplatform.net/natural-language-classifier/api';\n\n/**\n * Creates a classifier\n */\nNaturalLanguageClassifierV1.prototype.create = function(params, callback) {\n  params = params || {};\n\n  if (!params || !params.training_data) {\n    callback(new Error('Missing required parameters: training_data'));\n    return;\n  }\n  if (!(Array.isArray(params.training_data) || typeof params.training_data === 'string' || isStream(params.training_data))) {\n    callback(new Error('training_data needs to be a String, Array or Stream'));\n    return;\n  }\n\n  const self = this;\n\n  toCSV(params.training_data, function(err, csv) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    const parameters = {\n      options: {\n        url: '/v1/classifiers',\n        method: 'POST',\n        json: true,\n        formData: {\n          training_data: csv,\n          training_metadata: JSON.stringify(omit(params, ['training_data']))\n        },\n        // hack to check required parameters.\n        // We don't actually need path parameters\n        path: pick(params, ['language'])\n      },\n      requiredParams: ['language'],\n      defaultOptions: self._options\n    };\n    return requestFactory(parameters, callback);\n  });\n};\n\n/**\n * Returns the classification information for a classifier on a phrase\n */\nNaturalLanguageClassifierV1.prototype.classify = function(params, callback) {\n  params = params || {};\n\n  // #84: use classifier_id not classifier.\n  if (!params.classifier_id) {\n    params.classifier_id = params.classifier;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/classifiers/{classifier_id}/classify',\n      method: 'POST',\n      json: true,\n      path: pick(params, ['classifier_id']),\n      body: pick(params, ['text'])\n    },\n    requiredParams: ['classifier_id', 'text'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns the training status of the classifier\n */\nNaturalLanguageClassifierV1.prototype.status = function(params, callback) {\n  params = params || {};\n\n  // #84: use classifier_id not classifier.\n  if (!params.classifier_id) {\n    params.classifier_id = params.classifier;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/classifiers/{classifier_id}',\n      method: 'GET',\n      json: true,\n      path: params\n    },\n    requiredParams: ['classifier_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Retrieves the list of classifiers for the user\n */\nNaturalLanguageClassifierV1.prototype.list = function(params, callback) {\n  const parameters = {\n    options: {\n      url: '/v1/classifiers',\n      method: 'GET',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Deletes a classifier\n */\nNaturalLanguageClassifierV1.prototype.remove = function(params, callback) {\n  params = params || {};\n\n  // #84: use classifier_id not classifier.\n  if (!params.classifier_id) {\n    params.classifier_id = params.classifier;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/classifiers/{classifier_id}',\n      method: 'DELETE',\n      path: params,\n      json: true\n    },\n    requiredParams: ['classifier_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = NaturalLanguageClassifierV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/natural-language-classifier/json-training-to-csv.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst stringify = require('csv-stringify');\n\n/**\n * @private\n * @param {Object} data\n * @return {Array.<String>}\n */\nfunction toCSVArray(data) {\n  if (data.text && data.classes && data.classes.length > 0) {\n    return [data.text].concat(data.classes);\n  } else {\n    throw Error('Invalid training_data format, it needs to be: ' + '[{ text: \"my-text\", classes:[\"my-class1\", \"my-class2\",...]}, {}, ...]');\n  }\n}\n\n/**\n * IF traning is json, convert it to csv.\n * @param  {Object[]} jsonData the training_data as a json array\n * @param  {Function} cb the error first callback\n */\nmodule.exports = function toCSV(training, cb) {\n  if (Array.isArray(training)) {\n    try {\n      stringify(training.map(toCSVArray), cb);\n    } catch (e) {\n      cb(e);\n    }\n  } else {\n    cb(null, training);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/natural-language-understanding/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\nconst extend = require('extend');\n\n/**\n * NaturalLanguageUnderstanding\n * @param {Object} options\n * @constructor\n */\nfunction NaturalLanguageUnderstandingV1(options) {\n  BaseService.call(this, options);\n  if (typeof this._options.version_date === 'undefined') {\n    throw new Error('Argument error: version_date was not specified, use NaturalLanguageUnderstandingV1.VERSION_DATE_2017_02_27');\n  }\n  this._options.qs.version = this._options.version_date;\n}\nutil.inherits(NaturalLanguageUnderstandingV1, BaseService);\nNaturalLanguageUnderstandingV1.prototype.name = 'natural_language_understanding';\nNaturalLanguageUnderstandingV1.prototype.version = 'v1';\nNaturalLanguageUnderstandingV1.URL = 'https://gateway.watsonplatform.net/natural-language-understanding/api';\nNaturalLanguageUnderstandingV1.VERSION_DATE_2016_01_23 = '2016-01-23';\n// GA version date: 2017-02-27\n// https://www.ibm.com/watson/developercloud/doc/natural-language-understanding/release-notes.html\nNaturalLanguageUnderstandingV1.VERSION_DATE_2017_02_27 = '2017-02-27';\n\n/**\n * Bluemix uses hyphens instead of underscores for NLU in the VCAP_SERVICES env property.\n * No idea why.\n *\n * This method also checks for the underscore'd version just in case they ever change it.\n *\n * @private\n * @override\n */\nNaturalLanguageUnderstandingV1.prototype.getCredentialsFromBluemix = function(name) {\n  return extend(\n    {},\n    BaseService.prototype.getCredentialsFromBluemix.call(this, name),\n    BaseService.prototype.getCredentialsFromBluemix.call(this, name.replace(/_/g, '-'))\n  );\n};\n\n/**\n  * Analyze the query.\n  * @params {object} params for the query\n  * @param {object} [params.headers] - The headers added\n  * @param {string} [params.text] - The text to analyze.\n  * @param {string} [params.html] - The html to analyze.\n  * @param {string} [params.url] - The url to fetch and analyze.\n  * @param {object} [params.features] - The features to retrieve (need at least one)\n  * @param {object} [params.features.categories] - categories feature\n  * @param {object} [params.features.concepts] - concepts feature\n  * @param {object} [params.features.emotion] - emotion feature\n  * @param {object} [params.features.entities] - entities feature\n  * @param {object} [params.features.keywords] - keywords feature\n  * @param {object} [params.features.metadata] - metadata feature\n  * @param {object} [params.features.relations] - relations feature\n  * @param {object} [params.features.semantic_roles] - semantic roles feature\n  * @param {object} [params.features.sentiment] - sentiment feature\n  * @params {function} callback taking (error,  jsonResult)\n  * @example\n  * ```\n  * const options = {\n  *   'text': 'Natural Language Understanding analyzes unstructured text to return structured insights',\n  *   'features': {\n  *     'concepts': {\n  *       'limit': 3\n  *     },\n  *     'emotion': {},\n  *   },\n  * };\n  * nlu.analyze(options, myCallbackFunction);\n  * ```\n  * @return {void}\n  */\nNaturalLanguageUnderstandingV1.prototype.analyze = function(params, callback) {\n  const parameters = {\n    options: {\n      url: '/v1/analyze',\n      method: 'POST',\n      json: true,\n      body: params\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n  * List custom models deployed to your service instance.\n  * @params {object} params for the query\n  * @param {object} [params.headers] - The headers added\n  * @params {function} callback taking (error,  jsonResult)\n  * @example\n  * ```\n  * nlu.listModels({}, myCallbackFunction);\n  * ```\n  * @return {void}\n  */\nNaturalLanguageUnderstandingV1.prototype.listModels = function(params, callback) {\n  const parameters = {\n    options: {\n      url: '/v1/models',\n      method: 'GET',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n  * Delete a custom model that is deployed to your service instance.\n  * @params {object} params for the query\n  * @param {object} [params.headers] - The headers added\n  * @param {string} [params.model_id] - ID of the custom model to delete\n  * @params {function} callback taking (error,  jsonResult)\n  * @example\n  * ```\n  * const options = {\n  *   'model_id': 'myModel123'\n  * };\n  * nlu.deleteModel(options, myCallbackFunction);\n  * ```\n  * @return {void}\n  */\nNaturalLanguageUnderstandingV1.prototype.deleteModel = function(params, callback) {\n  const parameters = {\n    options: {\n      method: 'DELETE',\n      url: '/v1/models/{model_id}',\n      path: params,\n      json: true\n    },\n    requiredParams: ['model_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = NaturalLanguageUnderstandingV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/personality-insights/v2.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst pick = require('object.pick');\nconst helper = require('../lib/helper');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction PersonalityInsightsV2(options) {\n  BaseService.call(this, options);\n}\nutil.inherits(PersonalityInsightsV2, BaseService);\nPersonalityInsightsV2.prototype.name = 'personality_insights';\nPersonalityInsightsV2.prototype.version = 'v2';\nPersonalityInsightsV2.URL = 'https://gateway.watsonplatform.net/personality-insights/api';\n\n/**\n * @param params {Object} The parameters to call the service\n *   The accepted parameters are:\n *     - text: The text to analyze.\n *     - contentItems: A JSON input (if 'text' not provided).\n *     - include_raw: include raw results\n *     - accept_language : The language expected for the output.\n *     - language: The language of the input.\n *\n * @param callback The callback.\n */\nPersonalityInsightsV2.prototype.profile = function(\n  params,\n  callback // eslint-disable-line complexity\n) {\n  params = params || {};\n\n  // support for the new snake_case\n  if (params.content_items) {\n    params.contentItems = params.content_items;\n  }\n\n  if (!params.text && !params.contentItems) {\n    callback(new Error('Missing required parameters: text or content_items'));\n    return;\n  }\n\n  // Content-Type\n  let content_type = null;\n  if (params.text) {\n    content_type = helper.isHTML(params.text) ? 'text/html' : 'text/plain';\n  } else {\n    content_type = 'application/json';\n  }\n\n  const headers = {\n    'Content-type': content_type,\n    'Accept-language': params.accept_language || params.acceptLanguage || 'en'\n  };\n\n  // service bug: language in header overrides language in each JSON content item, so we can't set it on those requests\n  // (also, content-language doesn't really make sense on JSON)\n  if (params.language || params.text) {\n    headers['Content-language'] = params.language || 'en';\n  }\n\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v2/profile',\n      body: params.text || pick(params, ['contentItems']),\n      json: true,\n      qs: pick(params, ['include_raw']),\n      headers: headers\n    },\n    defaultOptions: this._options\n  };\n\n  if (params.csv) {\n    parameters.options.headers.Accept = 'text/csv';\n    if (params.csv_headers) {\n      parameters.options.qs.headers = 'true';\n    }\n  }\n\n  return requestFactory(parameters, callback);\n};\nmodule.exports = PersonalityInsightsV2;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/personality-insights/v3.js":"/**\n * Copyright 2016 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst pick = require('object.pick');\nconst extend = require('extend');\nconst helper = require('../lib/helper');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction PersonalityInsightsV3(options) {\n  BaseService.call(this, options);\n\n  // Check if 'version_date' was provided\n  if (typeof this._options.version_date === 'undefined') {\n    throw new Error('Argument error: version_date was not specified, use 2016-10-19');\n  }\n  this._options.qs.version = options.version_date;\n}\nutil.inherits(PersonalityInsightsV3, BaseService);\nPersonalityInsightsV3.prototype.name = 'personality_insights';\nPersonalityInsightsV3.prototype.version = 'v3';\nPersonalityInsightsV3.URL = 'https://gateway.watsonplatform.net/personality-insights/api';\n\n/**\n * @param {Object} params The parameters to call the service\n * @param {Object} [params.headers] - The header parameters.\n * @param {string} [params.headers.accept-language=en] - The desired language of the response.\n * @param {string} [params.headers.content-type=text/plain] - The content type of the request: text/plain (the default), text/html, or application/json.\n * @param {string} [params.headers.content-language=en] - The language of the input text for the request: ar (Arabic), en (English), es (Spanish), or ja (Japanese)\n * @param {string} [params.headers.accept=application/json] - The desired content type of the response: application/json (the default) or text/csv\n * @param {string} [params.text] - The text to analyze.\n * @param {Object} [params.content_items] - A JSON input (if 'text' not provided).\n * @param {boolean} [params.raw_scores=false] - include raw results.\n * @param {boolean} [params.csv_headers=false] - If true, column labels are returned with a CSV response; if false (the default), they are not. Applies only when the Accept header is set to text/csv.\n * @param {boolean} [params.consumption_preferences=false] - If true, information about consumption preferences is returned with the results.\n *\n * @param callback The callback.\n */\nPersonalityInsightsV3.prototype.profile = function(\n  _params,\n  callback // eslint-disable-line complexity\n) {\n  const params = extend({}, _params);\n\n  if (params.content_items) {\n    params.contentItems = params.content_items;\n  }\n\n  if (!params.text && !params.contentItems) {\n    callback(new Error('Missing required parameters: text or content_items'));\n    return;\n  }\n\n  // Content-Type\n  let content_type = null;\n  if (params.text) {\n    content_type = helper.isHTML(params.text) ? 'text/html' : 'text/plain';\n  } else {\n    content_type = 'application/json';\n  }\n\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v3/profile',\n      body: params.text || pick(params, ['contentItems']),\n      json: true,\n      qs: pick(params, ['csv_headers', 'raw_scores', 'consumption_preferences']),\n      headers: extend({ 'content-type': content_type, 'accept-language': 'en' }, params.headers)\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\nmodule.exports = PersonalityInsightsV3;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/retrieve-and-rank/v1.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst url = require('url');\nconst requestFactory = require('../lib/requestwrapper');\nconst solr = require('solr-client');\nconst helper = require('../lib/helper');\nconst pick = require('object.pick');\nconst omit = require('object.omit');\nconst isStream = require('isstream');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction RetrieveAndRankV1(options) {\n  BaseService.call(this, options);\n}\nutil.inherits(RetrieveAndRankV1, BaseService);\nRetrieveAndRankV1.prototype.name = 'retrieve_and_rank';\nRetrieveAndRankV1.prototype.version = 'v1';\nRetrieveAndRankV1.URL = 'https://gateway.watsonplatform.net/retrieve-and-rank/api';\n\n/**\n * Creates a ranker\n */\nRetrieveAndRankV1.prototype.createRanker = function(params, callback) {\n  params = params || {};\n\n  if (!params || !params.training_data) {\n    callback(new Error('Missing required parameters: training_data'));\n    return;\n  }\n  if (typeof params.training_data !== 'string' && !isStream(params.training_data)) {\n    callback(new Error('training_data needs to be a String or Stream'));\n    return;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/rankers',\n      method: 'POST',\n      json: true,\n      formData: {\n        training_data: params.training_data,\n        training_metadata: params.training_metadata || JSON.stringify(omit(params, ['training_data']))\n      }\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns the ranked candidates\n *\n * @param {Object} params - everything except answer_data and answers will be passed in as answer_metadata\n * @param {String|ReadableStream} params.answer_data\n * @param {Number} [params.answers] - number of answers to return\n * @param {Function} callback\n */\nRetrieveAndRankV1.prototype.rank = function(params, callback) {\n  params = params || {};\n\n  if (!params || !params.answer_data) {\n    callback(new Error('Missing required parameters: answer_data'));\n    return;\n  }\n  if (typeof params.answer_data !== 'string' && !isStream(params.answer_data)) {\n    callback(new Error('answer_data needs to be a String or Stream'));\n    return;\n  }\n\n  const topLevelParams = ['answer_data', 'answers'];\n  const formData = pick(params, topLevelParams);\n  formData.answer_metadata = JSON.stringify(omit(params, topLevelParams));\n\n  const parameters = {\n    options: {\n      url: '/v1/rankers/{ranker_id}/rank',\n      method: 'POST',\n      json: true,\n      formData: formData,\n      path: pick(params, ['ranker_id'])\n    },\n    requiredParams: ['ranker_id'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns the training status of the ranker\n */\nRetrieveAndRankV1.prototype.rankerStatus = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/rankers/{ranker_id}',\n      method: 'GET',\n      json: true,\n      path: params\n    },\n    requiredParams: ['ranker_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Retrieves the list of rankers for the user\n */\nRetrieveAndRankV1.prototype.listRankers = function(params, callback) {\n  const parameters = {\n    options: {\n      url: '/v1/rankers',\n      method: 'GET',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Deletes a ranker\n */\nRetrieveAndRankV1.prototype.deleteRanker = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/rankers/{ranker_id}',\n      method: 'DELETE',\n      path: params,\n      json: true\n    },\n    requiredParams: ['ranker_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n// Solr cluster lifecycle operations\n\n/**\n * Lists all Solr clusters associated with the service instance.\n *\n * @param params An Object representing the parameters for this service call.\n *   This request currently does not require any parameters.\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.listClusters = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters',\n      method: 'GET',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Creates a Solr cluster.\n *\n * @param params An Object representing the parameters for this service call.\n *   Optional params\n *     - cluster_name: name to use for identifying the cluster in responses\n *     - cluster_size: size of the cluster to create\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.createCluster = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters',\n      method: 'POST',\n      json: true,\n      body: params\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Checks whether the specified Solr cluster is ready for use.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to poll\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.pollCluster = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}',\n      method: 'GET',\n      path: params,\n      json: true\n    },\n    requiredParams: ['cluster_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Change the size of the Solr cluster.\n\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to poll\n *     - cluster_size: the integer size to resize the cluster to\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.resizeCluster = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/cluster_size',\n      method: 'PUT',\n      body: { cluster_size: params.cluster_size },\n      path: params,\n      json: true\n    },\n    requiredParams: ['cluster_id', 'cluster_size'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get the status of a resize request.\n\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to poll\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.getResizeStatus = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/cluster_size',\n      method: 'GET',\n      path: params,\n      json: true\n    },\n    requiredParams: ['cluster_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Deletes a Solr cluster.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to delete\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.deleteCluster = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}',\n      method: 'DELETE',\n      path: params,\n      json: true\n    },\n    requiredParams: ['cluster_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get memory and disk usage stats from a Solr cluster\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to get stats from\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.getClusterStats = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/stats',\n      method: 'GET',\n      path: params,\n      json: true\n    },\n    requiredParams: ['cluster_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n// Solr config operations\n\n/**\n * Lists the configuration sets in ZooKeeper.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to get configuration from\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.listConfigs = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/config',\n      method: 'GET',\n      path: params,\n      json: true\n    },\n    requiredParams: ['cluster_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Upload a configuration set to ZooKeeper.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to upload configuration to\n *     - config_name: the name of the config in ZooKeeper referenced when creating a collection\n *     - config_zip_path: the ZIP file to upload\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.uploadConfig = function(params, callback) {\n  params = params || {};\n\n  if (!params || !params.config_zip_path) {\n    callback(new Error('Missing required parameters: config_zip_path'));\n    return;\n  }\n  let configFile = null;\n  if (typeof params.config_zip_path === 'string') {\n    configFile = fs.createReadStream(params.config_zip_path);\n  } else if (isStream(params.config_zip_path)) {\n    configFile = params.config_zip_path;\n  } else {\n    callback(new Error('config_zip_path needs to be a String or Stream'));\n    return;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/config/{config_name}',\n      method: 'POST',\n      path: params\n    },\n    requiredParams: ['cluster_id', 'config_name'],\n    defaultOptions: this._options\n  };\n\n  return configFile\n    .on('response', function(response) {\n      // Replace content-type\n      response.headers['content-type'] = 'application/zip';\n    })\n    .pipe(requestFactory(parameters, callback));\n};\n\n/**\n * Get a configuration set from ZooKeeper as a .zip file.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to get configuration from\n *     - config_name: the name of the config in ZooKeeper\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.getConfig = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/config/{config_name}',\n      method: 'GET',\n      path: params,\n      json: true,\n      headers: {\n        accept: 'application/zip'\n      }\n    },\n    requiredParams: ['cluster_id', 'config_name'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Delete a configuration set in ZooKeeper.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to delete configuration from\n *     - config_name: the name of the config in ZooKeeper\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.deleteConfig = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/config/{config_name}',\n      method: 'DELETE',\n      path: params,\n      json: true\n    },\n    requiredParams: ['cluster_id', 'config_name'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n// Solr collection operations\n\n/**\n * List all collections for a Solr cluster.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to list collections from\n *   Optional params:\n *     - wt: the writer type for the response, defaults to 'json'\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.listCollections = function(params, callback) {\n  params = params || {};\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/solr/admin/collections',\n      method: 'GET',\n      qs: {\n        action: 'LIST',\n        wt: params.wt || 'json'\n      },\n      path: params,\n      json: true\n    },\n    requiredParams: ['cluster_id'],\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Create a Solr collection.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to create the collection on\n *     - collection_name: the name of the collection to create\n *     - config_name: the name of the config in ZooKeeper\n *   Optional params:\n *     - wt: the writer type for the response, defaults to 'json'\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.createCollection = function(params, callback) {\n  params = params || {};\n\n  const missingParams = helper.getMissingParams(params, ['cluster_id', 'collection_name', 'config_name']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n\n  const queryParams = {\n    'collection.configName': params.config_name,\n    name: params.collection_name,\n    wt: params.wt || 'json',\n    action: 'CREATE'\n  };\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/solr/admin/collections',\n      method: 'POST',\n      qs: queryParams,\n      path: pick(params, ['cluster_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Delete a Solr collection.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to delete the collection on\n *     - collection_name: the name of the collection to delete\n *   Optional params:\n *     - wt: the writer type for the response, defaults to 'json'\n *\n * @param callback The callback.\n */\nRetrieveAndRankV1.prototype.deleteCollection = function(params, callback) {\n  params = params || {};\n\n  const missingParams = helper.getMissingParams(params, ['cluster_id', 'collection_name']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n\n  const queryParams = {\n    name: params.collection_name,\n    wt: params.wt || 'json',\n    action: 'DELETE'\n  };\n\n  const parameters = {\n    options: {\n      url: '/v1/solr_clusters/{cluster_id}/solr/admin/collections',\n      method: 'POST',\n      qs: queryParams,\n      path: pick(params, ['cluster_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get a Solr client for indexing and searching documents.\n * See https://github.com/lbdremy/solr-node-client for documentation and examples.\n *\n * @param params An Object representing the parameters for this service call.\n *   Required params:\n *     - cluster_id: the ID of the Solr cluster to delete the collection on\n *     - collection_name: the name of the collection for indexing/searching\n */\nRetrieveAndRankV1.prototype.createSolrClient = function(params) {\n  params = params || {};\n\n  const missingParams = helper.getMissingParams(params, ['cluster_id', 'collection_name']);\n  if (missingParams) {\n    throw missingParams;\n  }\n\n  const serviceUrl = url.parse(this._options.url);\n  const apiPath = serviceUrl.path === '/' ? '' : serviceUrl.path || '';\n\n  const solrClient = solr.createClient({\n    host: serviceUrl.hostname,\n    path: apiPath + '/v1/solr_clusters/' + params.cluster_id + '/solr',\n    port: serviceUrl.port || '443',\n    secure: true,\n    core: params.collection_name\n  });\n\n  if (this._options.username && this._options.password) {\n    solrClient.basicAuth(this._options.username, this._options.password);\n  }\n  return solrClient;\n};\n\nmodule.exports = RetrieveAndRankV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/speech-to-text/v1.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst extend = require('extend');\nconst helper = require('../lib/helper');\nconst cookie = require('cookie');\nconst pick = require('object.pick');\nconst url = require('url');\nconst https = require('https');\nconst http = require('http');\nconst isStream = require('isstream');\nconst requestFactory = require('../lib/requestwrapper');\nconst RecognizeStream = require('./recognize_stream');\nconst pkg = require('../package.json');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\nconst async = require('async');\n\nconst PARAMS_ALLOWED = [\n  'continuous',\n  'max_alternatives',\n  'timestamps',\n  'word_confidence',\n  'inactivity_timeout',\n  'model',\n  'content-type', // this is accepted in querystring by the service, but methods here all accept content_type and then set a header\n  'interim_results',\n  'keywords',\n  'keywords_threshold',\n  'word_alternatives_threshold',\n  'profanity_filter',\n  'smart_formatting',\n  'customization_id',\n  'speaker_labels'\n];\n\n/**\n * @private\n * @param chunk\n * @return {*}\n */\nfunction formatChunk(chunk) {\n  // Convert the string into an array\n  let result = chunk;\n\n  // Check if in the stream doesn't have\n  // two results together and parse them\n  if (!result || result.indexOf('}{') === -1) {\n    return JSON.parse(result);\n  }\n\n  // Check if we can parse the response\n  try {\n    result = '[' + result.replace(/}{/g, '},{') + ']';\n    result = JSON.parse(result);\n    return result[result.length - 1];\n  } catch (e) {\n    // if it fails, then this isn't valid json (or a concatenated list of valid json) - just return the original string\n  }\n\n  return result;\n}\n\n/**\n * Speech Recognition API Wrapper\n * @constructor\n * @param {Object} options\n */\nfunction SpeechToTextV1(options) {\n  BaseService.call(this, options);\n}\n\nutil.inherits(SpeechToTextV1, BaseService);\nSpeechToTextV1.prototype.name = 'speech_to_text';\nSpeechToTextV1.prototype.version = 'v1';\nSpeechToTextV1.URL = 'https://stream.watsonplatform.net/speech-to-text/api';\n\n/**\n * Registers a callback URL with the service for use with subsequent asynchronous recognition requests.\n * The service attempts to register, or white-list, the callback URL if it is not already registered by sending a GET\n * request to the callback URL.\n *\n * @param {object} params - The parameters\n * @param {string} params.callback_url - A URL to which callback notifications are to be sent\n * @param {string} [params.user_secret] - A user-specified string that the service uses to generate the HMAC-SHA1 signature that it sends via the X-Callback-Signature header\n * @param {Function} callback\n * @returns {ReadableStream|undefined}\n */\nSpeechToTextV1.prototype.registerCallback = function(params, callback) {\n  const missingParams = helper.getMissingParams(params, ['callback_url']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n\n  const parameters = {\n    requiredParams: ['callback_url'],\n    options: {\n      method: 'POST',\n      url: '/v1/register_callback',\n      qs: pick(params, ['callback_url', 'user_secret']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Creates a job for a new asynchronous recognition request.\n * The job is owned by the user whose service credentials are used to create it.\n * How you learn the status and results of a job depends on the parameters you include with the job creation request.\n *\n * @param {object} params - The parameters\n * @param {Stream}  params.audio - Audio to be recognized\n * @param {string} params.content_type - The Content-type e.g. audio/l16; rate=48000\n * @param {string} params.callback_url - A URL to which callback notifications are to be sent\n * @param {string|Array<string>} [params.events] - Events to trigger the callback for. Valid options are recognitions.started, recognitions.completed, recognitions.failed, recognitions.completed_with_results\n * @param {string} [params.user_token] - The token allows the user to maintain an internal mapping between jobs and notification events\n * @param {number} [params.results_ttl] - time to alive of the job result\n * @param {*} [params.*] - all params that .recognize() accepts may also be passed to createRecognitionJob()\n * @param {Function} callback\n * @returns {ReadableStream|undefined}\n */\nSpeechToTextV1.prototype.createRecognitionJob = function(params, callback) {\n  const missingParams = helper.getMissingParams(params, ['audio', 'content_type']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n\n  if (!isStream(params.audio)) {\n    callback(new Error('audio is not a standard Node.js Stream'));\n    return;\n  }\n\n  const qs = pick(params, ['callback_url', 'events', 'user_token', 'results_ttl'].concat(PARAMS_ALLOWED));\n\n  // multiple events must be sent as a comma-separated string. Default behavior is multiple &event= params in the querystring\n  if (Array.isArray(qs.events)) {\n    qs.events = qs.events.join(',');\n  }\n\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v1/recognitions',\n      headers: {\n        'Content-Type': params.content_type\n      },\n      qs: qs,\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return params.audio\n    .on('response', function(response) {\n      // Replace content-type\n      response.headers['content-type'] = params.content_type;\n    })\n    .pipe(requestFactory(parameters, callback));\n};\n\n/**\n * Returns the status and ID of all outstanding jobs associated with the service credentials with which it is called.\n * The method also returns the creation and update times of each job, and, if a job was created with a callback URL\n * and a user token, the user token for the job.\n *\n * @param {Object} [params]\n * @param {Function} callback\n * @returns {ReadableStream|undefined}\n */\nSpeechToTextV1.prototype.getRecognitionJobs = function(params, callback) {\n  if (!callback && typeof params === 'function') {\n    callback = params;\n  }\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v1/recognitions',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns the status and ID of all outstanding jobs associated with the service credentials with which it is called.\n *\n * @param params\n * @param params.id - id of the Job\n * @param callback\n * @returns {ReadableStream|undefined}\n */\nSpeechToTextV1.prototype.getRecognitionJob = function(params, callback) {\n  const missingParams = helper.getMissingParams(params, ['id']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v1/recognitions/{id}',\n      path: pick(params, ['id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Deletes the specified job. You cannot delete a job that the service is actively processing.\n *\n * @param params - The parameters\n * @param params.id - id of the Job\n * @param callback\n * @returns {ReadableStream|undefined}\n */\nSpeechToTextV1.prototype.deleteRecognitionJob = function(params, callback) {\n  const missingParams = helper.getMissingParams(params, ['id']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n\n  const parameters = {\n    options: {\n      method: 'DELETE',\n      url: '/v1/recognitions/{id}',\n      path: pick(params, ['id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Speech recognition for given audio using default model.\n *\n * @param {Object} params The parameters\n * @param {Stream} params.audio - Audio to be recognized\n * @param {String} params.content_type - Content-type\n * @param {Boolean} [params.continuous],\n * @param {Number} [params.max_alternatives],\n * @param {Boolean} [params.timestamps],\n * @param {Boolean} [params.word_confidence],\n * @param {Number} [params.inactivity_timeout],\n * @param {String} [params.model],\n * @param {Boolean} [params.interim_results],\n * @param {Boolean} [params.keywords],\n * @param {Number} [params.keywords_threshold],\n * @param {Number} [params.word_alternatives_threshold],\n * @param {Boolean} [params.profanity_filter],\n * @param {Boolean} [params.smart_formatting],\n * @param {String} [params.customization_id],\n * @param {Boolean} [params.speaker_labels]\n * @param {function} callback\n */\nSpeechToTextV1.prototype.recognize = function(params, callback) {\n  const missingParams = helper.getMissingParams(params, ['audio', 'content_type']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n  if (!isStream(params.audio)) {\n    callback(new Error('audio is not a standard Node.js Stream'));\n    return;\n  }\n\n  const queryParams = pick(params, PARAMS_ALLOWED);\n  if (Array.isArray(queryParams.keywords)) {\n    queryParams.keywords = queryParams.keywords.join(',');\n  }\n\n  let _url = '/v1';\n  _url += params.session_id ? '/sessions/' + params.session_id : '';\n  _url += '/recognize';\n\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: _url,\n      headers: {\n        'Content-Type': params.content_type\n      },\n      json: true,\n      qs: queryParams\n    },\n    defaultOptions: this._options\n  };\n  return params.audio\n    .on('response', function(response) {\n      // Replace content-type\n      response.headers['content-type'] = params.content_type;\n    })\n    .pipe(requestFactory(parameters, callback));\n};\n\n/**\n * Creates a HTTP/HTTPS request to /recognize and keep the connection open.\n * Sets 'Transfer-Encoding': 'chunked' and prepare the connection to send\n * chunk data.\n *\n * @deprecated use createRecognizeStream instead\n *\n * @param {Object} params The parameters\n * @param {String} [params.content_type] - The Content-type e.g. audio/l16; rate=48000\n * @param {String} [params.session_id] - The session id\n * @param {function} callback\n */\nSpeechToTextV1.prototype.recognizeLive = function(params, callback) {\n  const missingParams = helper.getMissingParams(params, ['session_id', 'content_type', 'cookie_session']);\n\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n\n  const serviceUrl = [this._options.url, '/v1/sessions/', params.session_id, '/recognize'].join('');\n  const parts = url.parse(serviceUrl);\n  const options = {\n    agent: false,\n    host: parts.hostname,\n    port: parts.port,\n    path: parts.pathname + (params.continuous ? '?continuous=true' : ''),\n    method: 'POST',\n    headers: extend(\n      {\n        'Transfer-Encoding': 'chunked',\n        cookie: 'SESSIONID=' + params.cookie_session,\n        'Content-type': params.content_type\n      },\n      this._options.headers\n    )\n  };\n  const protocol = parts.protocol.match('http:') ? http : https;\n  const recognize_req = protocol.request(options, function(result) {\n    result.setEncoding('utf-8');\n    let transcript = '';\n\n    result.on('data', function(chunk) {\n      transcript += chunk;\n    });\n\n    result.on('end', function() {\n      try {\n        transcript = formatChunk(transcript);\n      } catch (e) {\n        callback(transcript);\n        return;\n      }\n      callback(null, transcript);\n    });\n  });\n\n  recognize_req.on('error', function(error) {\n    callback(error);\n  });\n  return recognize_req;\n};\n\n/**\n * Result observer for upcoming or ongoing recognition task in the session.\n * This request has to be started before POST on recognize finishes,\n * otherwise it waits for the next recognition.\n *\n * @deprecated use createRecognizeStream instead\n *\n * @param {Object} params The parameters\n * @param {String} [params.session_id] - Session used in the recognition\n * @param {boolean} [params.interim_results] - If true, interim results will be returned. Default: false\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.observeResult = function(params, callback) {\n  const missingParams = helper.getMissingParams(params, ['session_id', 'cookie_session']);\n  if (missingParams) {\n    callback(missingParams);\n    return;\n  }\n  const serviceUrl = [this._options.url, '/v1/sessions/', params.session_id, '/observe_result'].join('');\n  const parts = url.parse(serviceUrl);\n  const options = {\n    agent: false,\n    host: parts.hostname,\n    port: parts.port,\n    path: parts.pathname + (params.interim_results ? '?interim_results=true' : ''),\n    method: 'GET',\n    headers: extend(\n      {\n        cookie: 'SESSIONID=' + params.cookie_session,\n        Accept: 'application/json'\n      },\n      this._options.headers\n    )\n  };\n  const protocol = parts.protocol.match('http:') ? http : https;\n  const req = protocol.request(options, function(result) {\n    result.setEncoding('utf-8');\n    result.on('data', function(chunk) {\n      try {\n        chunk = formatChunk(chunk);\n      } catch (e) {\n        callback(chunk);\n        return;\n      }\n      callback(null, chunk);\n    });\n  });\n\n  req.on('error', function(error) {\n    callback(error);\n  });\n\n  req.end();\n\n  return req;\n};\n\n/**\n * Get the state of the engine to check if recognize is available.\n * This is the way to check if the session is ready to accept a new recognition task.\n * The returned state has to be 'initialized' to be able to do recognize POST.\n *\n * @deprecated use createRecognizeStream instead\n *\n * @param {Object} params The parameters\n * @param {String} [params.session_id] - Session used in the recognition\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.getRecognizeStatus = function(params, callback) {\n  const parameters = {\n    requiredParams: ['session_id'],\n    options: {\n      method: 'GET',\n      url: '/v1/sessions/{session_id}/recognize',\n      path: pick(params, ['session_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * List of models available.\n *\n * @param {Object} params The parameters\n * @param {Function} callback\n * @return {ReadableStream|undefined}\n */\nSpeechToTextV1.prototype.getModels = function(params, callback) {\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v1/models',\n      path: params,\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get information about a model based on the given model_id\n *\n * @param {Object} params The parameters\n * @param {String} params.model_id - The desired model\n * @param {Function} callback\n * @return {ReadableStream|undefined}\n */\nSpeechToTextV1.prototype.getModel = function(params, callback) {\n  const parameters = {\n    requiredParams: ['model_id'],\n    options: {\n      method: 'GET',\n      url: '/v1/models/{model_id}',\n      path: pick(params, ['model_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Create a session\n * Set-cookie header is returned with a cookie that must be used for\n * each request using this session.\n *\n * @param {Object} params The parameters\n * @param {string} params.model - The model to use during the session\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.createSession = function(params, callback) {\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v1/sessions',\n      json: true,\n      qs: params\n    },\n    defaultOptions: this._options\n  };\n\n  /**\n   * Add the cookie_session to the response\n   * @private\n   * @param cb\n   * @return {Function}\n   */\n  function addSessionId(cb) {\n    return function(error, body, response) {\n      if (error) {\n        cb(error, body, response);\n        return;\n      }\n      const cookies = cookie.parse(response.headers['set-cookie'][0]);\n      body.cookie_session = cookies.SESSIONID;\n      cb(error, body, response);\n    };\n  }\n\n  return requestFactory(parameters, addSessionId(callback));\n};\n\n/**\n * Deletes the specified session.\n *\n * @param {Object} params The parameters\n * @param {String} params.session_id - Session id.\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.deleteSession = function(params, callback) {\n  const parameters = {\n    requiredParams: ['session_id'],\n    options: {\n      method: 'DELETE',\n      url: '/v1/sessions/{session_id}',\n      json: true,\n      path: pick(params, ['session_id'])\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Replaces recognizeLive & friends with a single 2-way stream over websockets\n *\n * @param {Object} params The parameters\n * @return {RecognizeStream}\n */\nSpeechToTextV1.prototype.createRecognizeStream = function(params) {\n  params = params || {};\n  params.url = this._options.url;\n\n  params.headers = extend(\n    {\n      'user-agent': pkg.name + '-nodejs-' + pkg.version,\n      authorization: this._options.headers.Authorization\n    },\n    params.headers\n  );\n\n  return new RecognizeStream(params);\n};\n\n// set up a warning message for the deprecated methods\n['recognizeLive', 'observeResult'].forEach(function(name) {\n  const original = SpeechToTextV1.prototype[name];\n  SpeechToTextV1.prototype[name] = function deprecated(params) {\n    if (!(params || {}).silent && !this._options.silent) {\n      // eslint-disable-next-line no-console\n      console.log(\n        new Error(\n          `The ${name}() method is deprecated and will be removed from a future version of the watson-developer-cloud SDK. Please use createRecognizeStream() instead.\\n(Set {silent: true} to hide this message.)`\n        )\n      );\n    }\n    return original.apply(this, arguments);\n  };\n});\n\n/**\n * Creates a new empty custom voice model\n *\n * Response looks like:\n *\n * ```json\n * {\n *   \"customization_id\": \"abc996ea-86ca-482e-b7ec-0f31c34e5ee9\"\n * }\n * ```\n *\n * @param {Object} params The parameters\n * @param {String} params.base_model_name - The base language model, for example, en-US_BroadbandModel\n * @param {String} params.name - The customization name\n * @param {String} [params.description] - The customization description\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.createCustomization = function(params, callback) {\n  const parameters = {\n    requiredParams: ['base_model_name', 'name'],\n    options: {\n      method: 'POST',\n      url: '/v1/customizations',\n      body: pick(params, ['name', 'base_model_name', 'description']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * @typedef Word\n * @type {Object}\n * @property {String} word - The word as written\n * @property {String} translation - The phonetic or sounds-like translation for the word. A phonetic translation is based on the SSML format for representing the phonetic string of a word either as an IPA or IBM SPR translation. A sounds-like translation consists of one or more words that, when combined, sound like the word.\n */\n\n/**\n * List all customizations\n *\n * Example response:\n ```json\n { customizations:\n     [ { owner: '8a6f5bb1-5b2d-4a20-85a9-eaa421d25c88',\n         base_model_name: 'en-US_BroadbandModel',\n         customization_id: '6a7785a0-9665-11e6-a73a-0da9193a4475',\n         created: '2016-10-20T01:35:00.346Z',\n         name: 'IEEE-test',\n         description: '',\n         progress: 0,\n         language: 'en-US',\n         status: 'pending' },\n       { owner: '8a6f5bb1-5b2d-4a20-85a9-eaa421d25c88',\n         base_model_name: 'en-US_BroadbandModel',\n         customization_id: '9e2f6bb0-9665-11e6-a73a-0da9193a4475',\n         created: '2016-10-20T01:36:27.115Z',\n         name: 'IEEE-test',\n         description: '',\n         progress: 0,\n         language: 'en-US',\n         status: 'ready' },\n       { owner: '8a6f5bb1-5b2d-4a20-85a9-eaa421d25c88',\n         base_model_name: 'en-US_BroadbandModel',\n         customization_id: '6b194e70-9666-11e6-a73a-0da9193a4475',\n         created: '2016-10-20T01:42:10.903Z',\n         name: 'IEEE-test',\n         description: '',\n         progress: 100,\n         language: 'en-US',\n         status: 'available' } ] }\n\n ```\n *\n * @param {Object} params The parameters\n * @param {String} [params.language] optional filter.\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.getCustomizations = function(params, callback) {\n  if (typeof params === 'function' && !callback) {\n    callback = params;\n    params = {};\n  }\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/',\n      qs: pick(params, ['language']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get customization details\n *\n * Example response:\n *\n ```json\n { owner: '8a6f5bb1-5b2d-4a20-85a9-eaa421d25c88',\n   base_model_name: 'en-US_BroadbandModel',\n   customization_id: 'e695ad30-97c1-11e6-be92-bb627d4684b9',\n   created: '2016-10-21T19:09:33.443Z',\n   name: 'js-sdk-test-temporary',\n   description: 'Temporary customization to test the JS SDK. Should be automatically deleted within a few minutes.',\n   progress: 0,\n   language: 'en-US',\n   status: 'pending' }\n ```\n *\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.getCustomization = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id'],\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/{customization_id}',\n      path: pick(params, ['customization_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Train a custom model.\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {String} [params.word_type_to_add=all] - set to 'user' to train the model only on new words that were added or modified by the user; the model is not trained on new words extracted from corpora.\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.trainCustomization = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id'],\n    options: {\n      method: 'POST',\n      url: '/v1/customizations/{customization_id}/train',\n      path: pick(params, ['customization_id']),\n      qs: pick(params, ['word_type_to_add']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Reset a custom model.\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.resetCustomization = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id'],\n    options: {\n      method: 'POST',\n      url: '/v1/customizations/{customization_id}/reset',\n      path: pick(params, ['customization_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Delete a custom model.\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.deleteCustomization = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id'],\n    options: {\n      method: 'DELETE',\n      url: '/v1/customizations/{customization_id}',\n      path: pick(params, ['customization_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Add a corpus to a custom model.\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model to which a corpus is to be added. You must make the request with the service credentials of the model's owner.\n * @param {String} params.name - The name of the corpus that is to be added. The name cannot contain spaces and cannot be the string user, which is reserved by the service to denote custom words added or modified by the user.\n * @param {Boolean} [parms.allow_overwrite=false] - Indicates whether the specified corpus is to overwrite an existing corpus with the same name. If a corpus with the same name already exists, the request fails unless allow_overwrite is set to true; by default, the parameter is false. The parameter has no effect if a corpus with the same name does not already exist.\n * @param {String|Buffer|ReadStream} [params.corpus] - the text of the corpus - may be provided as a String, a Buffer, or a ReadableStream. A ReadableStream is recommended when reading a file from disk.\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.addCorpus = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'name', 'corpus'],\n    originalParams: params,\n    options: {\n      method: 'POST', // shouldn't this be a PUT?\n      url: '/v1/customizations/{customization_id}/corpora/{name}',\n      path: pick(params, ['customization_id', 'name']),\n      qs: pick(params, ['allow_overwrite']),\n      body: params.corpus\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * List corpora\n *\n * Lists information about all corpora that have been added to the specified custom language model.\n * The information includes the total number of words and out-of-vocabulary (OOV) words, name, and status of each corpus.\n *\n * Example Result:\n ```json\n {\n     \"corpora\": [{\n         \"out_of_vocabulary_words\": 1,\n         \"total_words\": 233,\n         \"name\": \"corpus-1\",\n         \"status\": \"analyzed\"\n     }, {\n         \"out_of_vocabulary_words\": 3,\n         \"total_words\": 20,\n         \"name\": \"corpus-2\",\n         \"status\": \"being_processed\"\n     }]\n }\n ```\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.getCorpora = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id'],\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/{customization_id}/corpora',\n      path: pick(params, ['customization_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get corpus details\n *\n * Example response:\n *\n ```json\n {\n   \"name\": \"corpus-1\",\n   \"total_words\": 100,\n   \"out_of_vocabulary_words\": 5,\n   \"status\": \"analyzed\"\n }\n ```\n *\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {String} params.name - The corpus name\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.getCorpus = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'name'],\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/{customization_id}/corpora/{name}',\n      path: pick(params, ['customization_id', 'name']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Delete a corpus.\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {String} params.name - The name of the corpus.\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.deleteCorpus = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'name'],\n    options: {\n      method: 'DELETE',\n      url: '/v1/customizations/{customization_id}/corpora/{name}',\n      path: pick(params, ['customization_id', 'name']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nSpeechToTextV1.ERR_NO_CORPORA = 'ERR_NO_CORPORA';\nSpeechToTextV1.ERR_TIMEOUT = 'ERR_TIMEOUT';\n\n/**\n * Waits while a customization status is 'pending' or 'training', fires callback once the status is 'ready' or 'available'.\n *\n * Note: the customization will remain in 'pending' status until at least one word corpus is added.\n *\n * See http://www.ibm.com/watson/developercloud/speech-to-text/api/v1/#list_models for status details.\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {Number} [params.interval=5000] - (milliseconds) - how log to wait between status checks\n * @param {Number} [params.times=30] - maximum number of attempts\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.whenCustomizationReady = function(params, callback) {\n  const self = this;\n\n  // check the customization status repeatedly until it's ready or available\n\n  const options = extend(\n    {\n      interval: 5000,\n      times: 30\n    },\n    params\n  );\n  options.errorFilter = function(err) {\n    // if it's a timeout error, then getCustomization is called again after params.interval\n    // otherwise the error is passed back to the user\n    // if the params.times limit is reached, the error will be passed to the user regardless\n    return err.code === SpeechToTextV1.ERR_TIMEOUT;\n  };\n  async.retry(\n    options,\n    function(next) {\n      self.getCustomization(params, function(err, customization) {\n        if (err) {\n          next(err);\n        } else if (customization.status === 'pending' || customization.status === 'training') {\n          // if the loop times out, async returns the last error, which will be this one.\n          err = new Error('Customization is still pending, try increasing interval or times params');\n          err.code = SpeechToTextV1.ERR_TIMEOUT;\n          next(err);\n        } else if (customization.status === 'ready' || customization.status === 'available') {\n          next(null, customization);\n        } else if (customization.status === 'failed') {\n          next(new Error('Customization training failed'));\n        } else {\n          next(new Error('Unexpected customization status: ' + customization.status));\n        }\n      });\n    },\n    callback\n  );\n};\n\n/**\n * Check if there is a corpus that is still being processed\n * @private\n * @param corporaList\n * @return {boolean}\n */\nfunction isProcessing(corporaList) {\n  const recordsBeingProcessed = corporaList.corpora.filter(function(record) {\n    return record['status'] === 'being_processed';\n  });\n  if (recordsBeingProcessed.length === 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n/**\n * Check if corpora has been analyzed\n * @private\n * @param corporaList\n * @return {boolean}\n */\nfunction isAnalyzed(corporaList) {\n  const recordsAnalyzed = corporaList.corpora.filter(function(record) {\n    return record['status'] === 'analyzed';\n  });\n  if (recordsAnalyzed.length === corporaList.corpora.length) {\n    return true;\n  } else {\n    return false;\n  }\n}\n/**\n * Waits while corpora analysis status is 'being_processes', fires callback once the status is 'analyzed'\n *\n * Note: the code will throw an error in case there in no corpus in the customization\n *\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {Number} [params.interval=5000] - (milliseconds) - how long to wait between status checks\n * @param {Number} [params.times=30] - maximum number of attempts\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.whenCorporaAnalyzed = function(params, callback) {\n  const self = this;\n\n  async.parallel(\n    [\n      // validate that it has at least one corpus\n      function(next) {\n        self.getCorpora(params, function(err, res) {\n          if (err) {\n            return next(err);\n          }\n          if (!res.corpora.length) {\n            err = new Error('Customization has no corpa and therefore corpus cannot be analyzed');\n            err.code = SpeechToTextV1.ERR_NO_CORPORA;\n            return next(err);\n          }\n          next();\n        });\n      },\n      // check the customization status repeatedly until it's available\n      function(next) {\n        const options = extend(\n          {\n            interval: 5000,\n            times: 30\n          },\n          params\n        );\n        options.errorFilter = function(err) {\n          // if it's a timeout error, then getCorpora is called again after params.interval\n          // otherwise the error is passed back to the user\n          // if the params.times limit is reached, the error will be passed to the user regardless\n          return err.code === SpeechToTextV1.ERR_TIMEOUT;\n        };\n        async.retry(\n          options,\n          function(done) {\n            self.getCorpora(params, function(err, corpora) {\n              if (err) {\n                done(err);\n              } else if (isProcessing(corpora)) {\n                // if the loop times out, async returns the last error, which will be this one.\n                err = new Error('Corpora is still being processed, try increasing interval or times params');\n                err.code = SpeechToTextV1.ERR_TIMEOUT;\n                done(err);\n              } else if (isAnalyzed(corpora)) {\n                done(null, corpora);\n              } else {\n                done(new Error('Unexpected corpus analysis status'));\n              }\n            });\n          },\n          next\n        );\n      }\n    ],\n    function(err, res) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, res[1]); // callback with the final customization object\n    }\n  );\n};\n\n/**\n * Add multiple custom words.\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {Array<Word>} params.words - Array of objects: [{word: String, sounds_like: [String, ...], display_as: String}, ...]\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.addWords = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'words'],\n    options: {\n      method: 'POST',\n      url: '/v1/customizations/{customization_id}/words',\n      path: pick(params, ['customization_id']),\n      body: pick(params, ['words']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Add a single custom word.\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {String} params.word - The custom word that is to be added to the custom model. Do not include spaces in the word. Use a - (dash) or _ (underscore) to connect the tokens of compound words.\n * @param {Array<String>} params.sounds_like - An array of sounds-like pronunciations for the custom word.\n * @param {String} [params.display_as] - An alternative spelling for the custom word when it appears in a transcript.\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.addWord = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'word', 'sounds_like'],\n    options: {\n      method: 'PUT',\n      url: '/v1/customizations/{customization_id}/words/{word}',\n      path: pick(params, ['customization_id', 'word']),\n      body: pick(params, ['sounds_like', 'display_as']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * List all custom words\n *\n * Lists information about all custom words from a custom language model.\n * You can list all words from the custom model's words resource, only custom words that were added or modified by the user, or only OOV words that were extracted from corpora.\n *\n * Example response:\n ```json\n {\n     \"words\": [\n        {\n           \"word\": \"hhonors\",\n           \"sounds_like\": [\"hilton honors\",\"h honors\"],\n           \"display_as\": \"HHonors\",\n           \"source\": [\"corpus1\"]\n        },\n        {\n           \"word\": \"ieee\",\n           \"sounds_like\": [\"i triple e\"],\n           \"display_as\": \"IEEE\",\n           \"source\": [\"corpus1\",\"corpus2\"]\n        },\n        {\n           \"word\": \"tomato\",\n           \"sounds_like\": [\"tomatoh\",\"tomayto\"],\n           \"display_as\": \"\",\n           \"source\": [\"user\"]\n        },\n        {\n           \"word\": \"$75.00\",\n           \"sounds_like\": [\"75 dollars\"],\n           \"display_as\": \"\",\n           \"source\": [\"user\"],\n           \"error\":\" Numbers are not allowed in sounds-like\"\n        }\n     ]\n  }\n ```\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {String} params.sort - +alphabetical|-alphabetical|+count|-count to order result in alphabetical oredering or count ordering.\n * @param {String} [params.word_type=all] - all|user|corpora - user shows only custom words that were added or modified by the user; corpora shows only OOV that were extracted from corpora.\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.getWords = function(params, callback) {\n  if (typeof params === 'function' && !callback) {\n    callback = params;\n    params = {};\n  }\n  const parameters = {\n    requiredParams: ['customization_id'],\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/{customization_id}/words',\n      path: pick(params, ['customization_id']),\n      qs: pick(params, ['word_type', 'sort']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get a custom word\n *\n * Lists information about a custom word from a custom language model.\n *\n * Example output:\n *\n * ```json\n {\n    \"sounds_like\": [\"N. C. A. A.\",\"N. C. double A.\"],\n    \"display_as\": \"NCAA\",\n    \"source\": [\"corpus3\",\"user\"]\n }\n ```\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {String} params.word - The custom word\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.getWord = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'word'],\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/{customization_id}/words/{word}',\n      path: pick(params, ['customization_id', 'word']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Delete a custom word\n *\n * Removing a custom word does not affect the custom model until you train the model with the Train a custom model method.\n *\n * @param {Object} params The parameters\n * @param {String} params.customization_id - The GUID of the custom language model\n * @param {String} params.word - The custom word that is to be deleted.\n * @param {Function} callback\n */\nSpeechToTextV1.prototype.deleteWord = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'word'],\n    options: {\n      method: 'DELETE',\n      url: '/v1/customizations/{customization_id}/words/{word}',\n      path: pick(params, ['customization_id', 'word']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = SpeechToTextV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/speech-to-text/recognize_stream.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst Duplex = require('stream').Duplex;\nconst util = require('util');\nconst extend = require('extend');\nconst pick = require('object.pick');\nconst W3CWebSocket = require('websocket').w3cwebsocket;\n\nconst OPENING_MESSAGE_PARAMS_ALLOWED = [\n  'continuous',\n  'max_alternatives',\n  'timestamps',\n  'word_confidence',\n  'inactivity_timeout',\n  'content-type',\n  'interim_results',\n  'keywords',\n  'keywords_threshold',\n  'word_alternatives_threshold',\n  'profanity_filter',\n  'smart_formatting',\n  'speaker_labels'\n];\n\nconst QUERY_PARAMS_ALLOWED = ['model', 'X-Watson-Learning-Opt-Out', 'watson-token', 'customization_id'];\n\n/**\n * pipe()-able Node.js Readable/Writeable stream - accepts binary audio and emits text in it's `data` events.\n * Also emits `results` events with interim results and other data.\n *\n * Cannot be instantiated directly, instead reated by calling #createRecognizeStream()\n *\n * Uses WebSockets under the hood. For audio with no recognizable speech, no `data` events are emitted.\n * @param {Object} options\n * @constructor\n */\nfunction RecognizeStream(options) {\n  Duplex.call(this, options);\n  this.options = options;\n  this.listening = false;\n  this.initialized = false;\n}\nutil.inherits(RecognizeStream, Duplex);\n\nRecognizeStream.prototype.initialize = function() {\n  const options = this.options;\n\n  // todo: apply these corrections to other methods (?)\n  if (options.token && !options['watson-token']) {\n    options['watson-token'] = options.token;\n  }\n  if (options.content_type && !options['content-type']) {\n    options['content-type'] = options.content_type;\n  }\n  if (options['X-WDC-PL-OPT-OUT'] && !options['X-Watson-Learning-Opt-Out']) {\n    options['X-Watson-Learning-Opt-Out'] = options['X-WDC-PL-OPT-OUT'];\n  }\n\n  const queryParams = extend({ model: 'en-US_BroadbandModel' }, pick(options, QUERY_PARAMS_ALLOWED));\n  const queryString = Object.keys(queryParams)\n    .map(function(key) {\n      return key + '=' + (key === 'watson-token' ? queryParams[key] : encodeURIComponent(queryParams[key])); // our server chokes if the token is correctly url-encoded\n    })\n    .join('&');\n\n  const url = (options.url || 'wss://stream.watsonplatform.net/speech-to-text/api').replace(/^http/, 'ws') + '/v1/recognize?' + queryString;\n\n  const openingMessage = extend(\n    {\n      action: 'start',\n      'content-type': 'audio/wav',\n      continuous: true,\n      interim_results: true,\n      word_confidence: true,\n      timestamps: true,\n      max_alternatives: 3,\n      inactivity_timeout: 600\n    },\n    pick(options, OPENING_MESSAGE_PARAMS_ALLOWED)\n  );\n\n  const closingMessage = { action: 'stop' };\n\n  const self = this;\n\n  // node params: requestUrl, protocols, origin, headers, extraRequestOptions\n  // browser params: requestUrl, protocols (all others ignored)\n  const socket = this.socket = new W3CWebSocket(url, null, null, options.headers, null);\n\n  // when the input stops, let the service know that we're done\n  self.on('finish', function() {\n    if (self.socket && self.socket.readyState === W3CWebSocket.OPEN) {\n      self.socket.send(JSON.stringify(closingMessage));\n    } else {\n      self.once('connect', function() {\n        self.socket.send(JSON.stringify(closingMessage));\n      });\n    }\n  });\n\n  socket.onerror = function(error) {\n    self.listening = false;\n    self.emit('error', error);\n  };\n\n  this.socket.onopen = function() {\n    socket.send(JSON.stringify(openingMessage));\n    self.emit('connect');\n  };\n\n  this.socket.onclose = function(e) {\n    self.listening = false;\n    self.push(null);\n    /**\n     * @event RecognizeStream#close\n     * @param {Number} reasonCode\n     * @param {String} description\n     */\n    self.emit('close', e.code, e.reason);\n  };\n\n  /**\n   * @event RecognizeStream#error\n   */\n  function emitError(msg, frame, err) {\n    if (err) {\n      err.message = msg + ' ' + err.message;\n    } else {\n      err = new Error(msg);\n    }\n    err.raw = frame;\n    self.emit('error', err);\n  }\n\n  socket.onmessage = function(frame) {\n    if (typeof frame.data !== 'string') {\n      return emitError('Unexpected binary data received from server', frame);\n    }\n\n    let data;\n    try {\n      data = JSON.parse(frame.data);\n    } catch (jsonEx) {\n      return emitError('Invalid JSON received from service:', frame, jsonEx);\n    }\n\n    let recognized = false;\n    if (data.error) {\n      emitError(data.error, frame);\n      recognized = true;\n    }\n\n    if (data.state === 'listening') {\n      // this is emitted both when the server is ready for audio, and after we send the close message to indicate that it's done processing\n      if (!self.listening) {\n        self.listening = true;\n        self.emit('listening');\n      } else {\n        self.listening = false;\n        socket.close();\n      }\n      recognized = true;\n    }\n\n    if (data.results) {\n      /**\n       * Object with interim or final results, including possible alternatives. May have no results at all for empty audio files.\n       * @event RecognizeStream#results\n       * @param {Object} results\n       */\n      self.emit('results', data);\n      // note: currently there is always either no entries or exactly 1 entry in the results array. However, this may change in the future.\n      if (data.results[0] && data.results[0].final && data.results[0].alternatives) {\n        /**\n         * Finalized text\n         * @event RecognizeStream#data\n         * @param {String} transcript\n         */\n        self.push(data.results[0].alternatives[0].transcript, 'utf8'); // this is the \"data\" event that can be easily piped to other streams\n      }\n      recognized = true;\n    }\n\n    // note: some messages will have both results and speaker_labels\n    // this will cause them to be emitted twice - once for each event\n    if (data.speaker_labels) {\n      /**\n       * Speaker labels\n       * @event RecognizeStream#speaker_labels\n       * @param {Object} speaker_labels\n       */\n      self.emit('speaker_labels', data);\n      recognized = true;\n    }\n\n    if (!recognized) {\n      emitError('Unrecognised message from server', frame);\n    }\n  };\n\n  this.initialized = true;\n};\n\nRecognizeStream.prototype._read = function() /* size*/ {\n  // there's no easy way to control reads from the underlying library\n  // so, the best we can do here is a no-op\n};\n\nRecognizeStream.prototype._write = function(chunk, encoding, callback) {\n  const self = this;\n  if (self.listening) {\n    self.socket.send(chunk);\n    this.afterSend(callback);\n  } else {\n    if (!this.initialized) {\n      if (!this.options['content-type']) {\n        this.options['content-type'] = RecognizeStream.getContentType(chunk);\n      }\n      this.initialize();\n    }\n    this.once('listening', function() {\n      self.socket.send(chunk);\n      self.afterSend(callback);\n    });\n  }\n};\n\n// flow control - don't ask for more data until we've finished what we have\n// todo: see if this can be improved\nRecognizeStream.prototype.afterSend = function afterSend(next) {\n  // note: bufferedAmount is currently always 0\n  // see https://github.com/theturtle32/WebSocket-Node/issues/243\n  if (this.socket.bufferedAmount <= (this._writableState.highWaterMark || 0)) {\n    process.nextTick(next);\n  } else {\n    setTimeout(this.afterSend.bind(this, next), 10);\n  }\n};\n\nRecognizeStream.prototype.stop = function() {\n  this.emit('stopping');\n  this.listening = false;\n  this.socket.close();\n};\n\n/**\n * Returns a Promise that resolves with Watson Transaction ID from the X-Transaction-ID header\n *\n * Works in Node.js but not in browsers (the W3C WebSocket API does not expose headers)\n *\n * @return Promise<String>\n */\nRecognizeStream.prototype.getTransactionId = function() {\n  if (this.socket && this.socket._client && this.socket._client.response && this.socket._client.response.headers) {\n    return Promise.resolve(this.socket._client.response.headers['x-global-transaction-id']);\n  } else {\n    return new Promise((resolve, reject) => {\n      this.on('connect', () => {\n        resolve(this.socket._client.response.headers['x-global-transaction-id']);\n      });\n      this.on('error', reject);\n    });\n  }\n};\n\n// quick/dumb way to determine content type from a supported file format\nconst headerToContentType = {\n  fLaC: 'audio/flac',\n  RIFF: 'audio/wav',\n  OggS: 'audio/ogg; codecs=opus'\n};\nRecognizeStream.getContentType = function(buffer) {\n  const header = buffer.slice(0, 4).toString();\n  return headerToContentType[header];\n};\n\nmodule.exports = RecognizeStream;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/text-to-speech/v1.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst pick = require('object.pick');\nconst extend = require('extend');\nconst requestFactory = require('../lib/requestwrapper');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n * Watson Text to Speech service\n *\n * @param {Object} options\n * @constructor\n */\nfunction TextToSpeechV1(options) {\n  BaseService.call(this, options);\n}\nutil.inherits(TextToSpeechV1, BaseService);\nTextToSpeechV1.prototype.name = 'text_to_speech';\nTextToSpeechV1.prototype.version = 'v1';\nTextToSpeechV1.URL = 'https://stream.watsonplatform.net/text-to-speech/api';\n\n/**\n * Streaming speech synthesis of the text in a query parameter\n *\n * @param {Object} params\n * @param {String} params.text\n * @param {String} [params.voice=en-US_MichaelVoice] - Call .voices() for a complete list\n * @param {String} [params.accept=audio/ogg;codecs=opus] - Supported formats are audio/ogg;codecs=opus, audio/wav, audio/flac, audio/l16, audio/basic\n * @param {Boolean} [params.X-Watson-Learning-Opt-Out]\n * @param {String} [params.customization_id]\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.synthesize = function(params, callback) {\n  params = extend({ accept: 'audio/ogg; codecs=opus' }, params);\n\n  const parameters = {\n    requiredParams: ['text'],\n    options: {\n      method: 'POST',\n      url: '/v1/synthesize',\n      body: JSON.stringify(pick(params, ['text'])),\n      qs: pick(params, ['accept', 'voice', 'customization_id']),\n      path: pick(params, ['text']),\n      headers: extend(\n        {\n          'content-type': 'application/json'\n        },\n        pick(params, ['X-Watson-Learning-Opt-Out'])\n      ),\n      encoding: null\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n// todo: add websocket support\n// http://www.ibm.com/watson/developercloud/text-to-speech/api/v1/?curl#www_synthesize12\n\n/**\n * Retrieves the voices available for speech synthesis\n * @param {Object} params\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.voices = function(params, callback) {\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v1/voices',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Retrieves information about the specified voice\n *\n * @param {Object} params\n * @param {String} params.voice\n * @param {String} [params.customization_id]\n */\nTextToSpeechV1.prototype.voice = function(params, callback) {\n  const parameters = {\n    requiredParams: ['voice'],\n    options: {\n      method: 'GET',\n      url: '/v1/voices/{voice}',\n      path: pick(params, ['voice']),\n      qs: pick(params, ['customization_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Returns the phonetic pronunciation for the specified word.\n *\n * @param {Object} params\n * @param {String} params.text - a single word\n * @param {String} [params.format=ipa] - Supported formats are ipa, spr for US English, or spr for other languages\n * @param {String} [params.voice] - Defaults to en-US_MichaelVoice unless a customization_id is specified. Do not specify both a voice and a customization_id\n * @param {String} [params.customization_id] - do not specify both a voice and a customization_id\n */\nTextToSpeechV1.prototype.pronunciation = function(params, callback) {\n  const parameters = {\n    requiredParams: ['text'],\n    options: {\n      method: 'GET',\n      url: '/v1/pronunciation',\n      qs: pick(params, ['text', 'voice', 'format', 'customization_id']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Creates a new empty custom voice model\n *\n * Response looks like:\n *\n * ```json\n * {\n *   \"customization_id\": \"abc996ea-86ca-482e-b7ec-0f31c34e5ee9\"\n * }\n * ```\n *\n * @param {Object} params\n * @param {String} params.name\n * @param {String} [params.language=en-US]\n * @param {String} [params.description]\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.createCustomization = function(params, callback) {\n  const parameters = {\n    requiredParams: ['name'],\n    options: {\n      method: 'POST',\n      url: '/v1/customizations',\n      body: pick(params, ['name', 'language', 'description']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * @typedef Word\n * @type {Object}\n * @property {String} word - the word as written\n * @property {String} translation - The phonetic or sounds-like translation for the word. A phonetic translation is based on the SSML format for representing the phonetic string of a word either as an IPA or IBM SPR translation. A sounds-like translation consists of one or more words that, when combined, sound like the word.\n */\n\n/**\n * Update voice model\n *\n * Updates information for the specified custom voice model.\n * You can update the metadata such as the name and description of the voice model.\n * You can also update the words in the model and their translations.\n * A custom model can contain no more than 20,000 entries.\n * Only the owner of a custom voice model can use this method to update the model.\n *\n * An example of params.words could be:\n *\n * ```json\n *  [\n *    {\"word\":\"NCAA\", \"translation\":\"N C double A\"},\n *    {\"word\":\"iPhone\", \"translation\":\"I phone\"}\n *  ]\n * ```\n *\n * @param {Object} params\n * @param {String} params.customization_id\n * @param {String} [params.name]\n * @param {String} [params.description]\n * @param {Array<Word>} params.words - Array of {word, translation} objects where translation is the phonetic or sounds-like translation for the word. A phonetic translation is based on the SSML format for representing the phonetic string of a word either as an IPA or IBM SPR translation. A sounds-like translation consists of one or more words that, when combined, sound like the word.\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.updateCustomization = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'words'],\n    originalParams: params,\n    options: {\n      method: 'POST',\n      url: '/v1/customizations/' + params.customization_id,\n      body: pick(params, ['name', 'description', 'words']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * List custom voice models\n *\n * Lists metadata such as the name and description for all custom voice models that you own for all languages.\n * Specify a language to list the voice models that you own for the specified language only.\n *\n * Example response:\n *\n * ```json\n{\n  \"customizations\": [\n    {\n      \"owner\": \"53fd7517-af0d-849d-801b-6e042a5d2f22\",\n      \"language\": \"en-US\",\n      \"created\": 1461173032707,\n      \"customization_id\": \"a4df11a9-7cf9-48e8-8319-08fb7c3b1aa8\",\n      \"name\": \"Second cURL Test\",\n      \"description\": \"Second customization test via cURL\",\n      \"last_modified\": 1461173032707\n    },\n    {\n      \"owner\": \"53fd7517-af0d-849d-801b-6e042a5d2f22\",\n      \"language\": \"en-US\",\n      \"created\": 1461173032106,\n      \"customization_id\": \"53506a62-6861-41f5-9a44-352047edcf6f\",\n      \"name\": \"First cURL Test Update\",\n      \"description\": \"First customization test via cURL update\",\n      \"last_modified\": 1461173033323\n    }\n  ]\n}```\n *\n *\n * @param {Object} [params]\n * @param {String} [params.language] optional filter.\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.getCustomizations = function(params, callback) {\n  if (typeof params === 'function' && !callback) {\n    callback = params;\n    params = {};\n  }\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/',\n      qs: pick(params, ['language']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get a custom voice model\n *\n * Lists all information about the specified custom voice model.\n * In addition to metadata such as the name and description of the voice model, the output includes the words in the model and their translations as defined in the model.\n * Only the owner of a custom voice model can use this method to query information about the model.\n *\n * Example response:\n * ```json\n {\n   \"words\": [\n     {\n       \"word\": \"NCAA\",\n       \"translation\": \"N C double A\"\n     },\n     {\n       \"word\": \"iPhone\",\n       \"translation\": \"I phone\"\n     }\n   ],\n   \"owner\": \"53fd7517-af0d-849d-801b-6e042a5d2f22\",\n   \"created\": 1461173032106,\n   \"language\": \"en-US\",\n   \"last_modified\": 1461173033323,\n   \"customization_id\": \"53506a62-6861-41f5-9a44-352047edcf6f\",\n   \"name\": \"First cURL Test Update\",\n   \"description\": \"First customization test via cURL update\"\n }```\n *\n *\n * @param {Object} params\n * @param {String} params.customization_id\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.getCustomization = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id'],\n    originalParams: params,\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/' + params.customization_id,\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Delete a custom voice model\n *\n * @param {Object} params\n * @param {String} params.customization_id\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.deleteCustomization = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id'],\n    originalParams: params,\n    options: {\n      method: 'DELETE',\n      url: '/v1/customizations/' + params.customization_id,\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Add words to a custom voice model\n *\n * Adds one or more words and their translations to the specified custom voice model.\n * A custom model can contain no more than 20,000 entries.\n *\n * An example of params.words could be:\n *\n * ```json\n *  [\n *    {\"word\":\"NCAA\", \"translation\":\"N C double A\"},\n *    {\"word\":\"iPhone\", \"translation\":\"I phone\"}\n *  ]\n * ```\n *\n * @param {Object} params\n * @param {String} params.customization_id\n * @param {Array<Word>} params.words - Array of {word, translation} objects where translation is the phonetic or sounds-like translation for the word. A phonetic translation is based on the SSML format for representing the phonetic string of a word either as an IPA or IBM SPR translation. A sounds-like translation consists of one or more words that, when combined, sound like the word.\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.addWords = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'words'],\n    originalParams: params,\n    options: {\n      method: 'POST',\n      url: '/v1/customizations/' + params.customization_id + '/words',\n      body: pick(params, ['words']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Add a word to a custom voice model\n *\n * Adds a single word and its translation to the specified custom voice model.\n * A custom model can contain no more than 20,000 entries.\n *\n * An example call could be\n *\n * ```json\n *  myTextToSpeech.addWord({\n *      customization_id: '<model-id>',\n *      word: 'ACLs',\n *      translation: 'ackles'\n *    },\n *    function(err, res) {\n *      console.log(err, res);\n *   });\n * ```\n *\n * @param {Object} params\n * @param {String} params.customization_id\n * @param {String} params.word\n * @param {String} params.translation - the phonetic or sounds-like translation for the word. A phonetic translation is based on the SSML format for representing the phonetic string of a word either as an IPA or IBM SPR translation. A sounds-like translation consists of one or more words that, when combined, sound like the word.\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.addWord = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'word', 'translation'],\n    originalParams: params,\n    options: {\n      method: 'PUT',\n      url: '/v1/customizations/' + params.customization_id + '/words/' + params.word,\n      body: pick(params, ['translation']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * List words\n *\n * Lists all of the words and their translations for the specified custom voice model.\n * The output shows the translations as they are defined in the model.\n *\n * Example response:\n *\n * ```json\n {\n    \"words\": [\n       {\n          \"word\": \"NCAA\",\n           \"translation\": \"N C double A\"\n       },\n       {\n          \"word\": \"iPhone\",\n          \"translation\": \"I phone\"\n       },\n       {\n          \"word\": \"EEE\",\n          \"translation\": \"<phoneme alphabet=\"ibm\" ph=\"tr1Ipxl.1i\"></phoneme>\"\n       },\n       {\n          \"word\": \"IEEE\",\n          \"translation\": \"<phoneme alphabet=\"ibm\" ph=\"1Y.tr1Ipxl.1i\"></phoneme>\"\n       },\n       {\n          \"word\": \"ACLs\",\n          \"translation\": \"ackles\"\n       }\n    ]\n }\n *  ```\n *\n * @param {Object} params\n * @param {String} params.customization_id\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.getWords = function(params, callback) {\n  if (typeof params === 'function' && !callback) {\n    callback = params;\n    params = {};\n  }\n  const parameters = {\n    requiredParams: ['customization_id'],\n    originalParams: params,\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/' + params.customization_id + '/words',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Get the translation for a single word from the specified custom model.\n *\n * Example output:\n *\n * ```json\n{\n  \"translation\": \"ackles\"\n}\n * ```\n *\n * @param {Object} params\n * @param {String} params.customization_id\n * @param {String} params.word\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.getWord = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'word'],\n    originalParams: params,\n    options: {\n      method: 'GET',\n      url: '/v1/customizations/' + params.customization_id + '/words/' + params.word,\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Deletes a single word from the specified custom voice model.\n *\n * @param {Object} params\n * @param {String} params.customization_id\n * @param {String} params.word\n * @param {Function} callback\n */\nTextToSpeechV1.prototype.deleteWord = function(params, callback) {\n  const parameters = {\n    requiredParams: ['customization_id', 'word'],\n    originalParams: params,\n    options: {\n      method: 'DELETE',\n      url: '/v1/customizations/' + params.customization_id + '/words/' + params.word,\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = TextToSpeechV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/tone-analyzer/v3.js":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst extend = require('extend');\nconst pick = require('object.pick');\nconst requestFactory = require('../lib/requestwrapper');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n * Tone Analyzer\n * @param {Object} options\n * @constructor\n */\nfunction ToneAnalyzerV3(options) {\n  BaseService.call(this, options);\n  // Check if 'version_date' was provided\n  if (typeof this._options.version_date === 'undefined') {\n    throw new Error('Argument error: version_date was not specified, use 2016-05-19');\n  }\n  // todo: confirm that the service wants version, not version_date\n  this._options.qs.version = this._options.version_date;\n}\nutil.inherits(ToneAnalyzerV3, BaseService);\nToneAnalyzerV3.prototype.name = 'tone_analyzer';\nToneAnalyzerV3.prototype.version = 'v3';\nToneAnalyzerV3.URL = 'https://gateway.watsonplatform.net/tone-analyzer/api';\n\n/**\n * Main API call. Returns the different tone dimensions of a text.\n *\n * @param params: An object with a string 'text' element.\n *\n * Additional arguments on `params` object are optional, they include:\n *\n * - `tones`: A Comma-separated list of tones. Only these will be computed\n *    in this API call. Allowed values are 'social', 'emotion', 'language'.\n *    It defaults to 'all of them'.\n * - `sentences`: A boolean, telling if sentence-level analysis (which is\n *    slower than just document-level) needs to be computed. It defaults\n *    to true.\n * - `isHTML`: A boolean value telling that the `params.text` argument is\n *    to be trated as HTML contents. On HTML input, the services does\n *    cleanup of tags and performs the analysis on the text contents only.\n *\n * @return upon success, the callback function is called with an object\n * containing the different tones (emotion, writing and social) analyzed.\n *\n * @see the API docs for a the full documentation.\n *\n */\nToneAnalyzerV3.prototype.tone = function(params, callback) {\n  if (!params || !params.text) {\n    callback(new Error('Missing required parameters: text'));\n    return;\n  }\n  const contentType = params.isHTML ? 'text/html' : 'text/plain';\n  const parameters = {\n    options: {\n      url: '/v3/tone',\n      method: 'POST',\n      body: params.text,\n      qs: pick(params, ['tones', 'sentences'])\n    },\n    defaultOptions: extend(true, this._options, {\n      headers: {\n        accept: 'application/json',\n        'content-type': contentType\n      }\n    })\n  };\n\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = ToneAnalyzerV3;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/tradeoff-analytics/v1.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst requestFactory = require('../lib/requestwrapper');\nconst omit = require('object.omit');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\n/**\n *\n * @param {Object} options\n * @constructor\n */\nfunction TradeoffAnalyticsV1(options) {\n  BaseService.call(this, options);\n}\nutil.inherits(TradeoffAnalyticsV1, BaseService);\nTradeoffAnalyticsV1.prototype.name = 'tradeoff_analytics';\nTradeoffAnalyticsV1.prototype.version = 'v1';\nTradeoffAnalyticsV1.URL = 'https://gateway.watsonplatform.net/tradeoff-analytics/api';\n\n/**\n * Returns a dilemma that contains the problem and a resolution.\n * The problem contains a set of options and objectives.\n * The resolution contains a set of optimal options,\n * their analytical characteristics, and representation on a 2D space.\n *\n * @param  {Array}  params.columns List of possible objectives\n * @param  {String} params.subject Name of the decision problem\n * @param  {String} params.options A list of options. Typically, the rows in a\n *                                 table representation of your data\n * @param  {String} params.metadataHeader Value of the x-watson-metadata header to be forwarded\n * \t\t\t\t\t\t\t\t                        for analytics purposes\n * @param  {String} params.generate_visualization Boolean (default = true). if false, the algorithm\n *                                                will not create the \"map\" visualization, and will typically run much faster\n * @param  {String} params.find_preferable_options Boolean (default = false). if true the algorithm includes a refined subset of best candidate options\n * that will most likely satisfy the greatest number of users.\n */\nTradeoffAnalyticsV1.prototype.dilemmas = function(params, callback) {\n  params = params || {};\n  const qs = {};\n  if (params.find_preferable_options) {\n    qs.find_preferable_options = true;\n  }\n  if (params.generate_visualization === false) {\n    qs.generate_visualization = false;\n  }\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v1/dilemmas',\n      body: omit(params, ['metadata_header', 'generate_visualization', 'find_preferable_options']),\n      headers: {\n        'x-watson-metadata': params.metadata_header\n      },\n      qs: qs,\n      json: true\n    },\n    requiredParams: ['columns', 'subject', 'options'],\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\n/**\n * Forward events from the Tradeoff Analytics widget to the service\n *\n * @param  {String} params - the array of events to forward to the service\n * @param  {String} params.metadataHeader Value of the x-watson-metadata header to be forwarded\n * \t\t\t\t\t\t\t\t   for analytics purposes\n */\nTradeoffAnalyticsV1.prototype.events = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      method: 'POST',\n      url: '/v1/events',\n      body: omit(params, ['metadata_header', 'generate_visualization']),\n      headers: {\n        'x-watson-metadata': params.metadata_header\n      },\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return requestFactory(parameters, callback);\n};\n\nmodule.exports = TradeoffAnalyticsV1;\n","/home/travis/build/npmtest/node-npmtest-watson-developer-cloud/watson-developer-cloud/visual-recognition/v3.js":"/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nconst extend = require('extend');\nconst pick = require('object.pick');\nconst isStream = require('isstream');\nconst requestFactory = require('../lib/requestwrapper');\nconst util = require('util');\nconst BaseService = require('../lib/base_service');\n\nconst NEGATIVE_EXAMPLES = 'negative_examples';\n\n/**\n * JS-style logical XOR - works on objects, booleans, strings, etc following normal js truthy/falsy conventions\n * @private\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n * @constructor\n */\nfunction xor(a, b) {\n  return (a || b) && !(a && b);\n}\n\n/**\n * Determine content-type header for .zip, .png, and .jpg files\n * (The only formats currently supported by the service)\n *\n * based on https://github.com/watson-developer-cloud/node-sdk/issues/333\n *\n * @param {Buffer} buffer\n * @return {String|undefined}\n */\nfunction detectContentType(buffer) {\n  const signature = buffer.readUInt32BE();\n  switch (signature) { // eslint-disable-line default-case\n    case 0x504b0304:\n    case 0x504b0506:\n    case 0x504b0708:\n      return 'application/zip';\n    case 0x89504e47:\n      return 'image/png';\n    case 0xffd8ffe0:\n    case 0xffd8ffe1:\n    case 0xffd8ffe8:\n      return 'image/jpeg';\n    // default is `return undefined`\n  }\n}\n\n/**\n * Verifies that a stream images_file or a string url is included\n * also gracefully handles cases of image_file instead of images_file\n *\n * @private\n * @param {Object} params\n */\nfunction fixupImageParam(params) {\n  if (params && params.image_file && !params.images_file) {\n    params.images_file = params.image_file;\n  }\n\n  if (!params || !xor(params.images_file, params.url)) {\n    throw new Error('Watson VisualRecognition.classify() requires either an images_file or a url parameter');\n  }\n\n  if (Buffer.isBuffer(params.images_file)) {\n    params.images_file = {\n      value: params.images_file,\n      options: {\n        contentType: detectContentType(params.images_file)\n      }\n    };\n  }\n}\n\n/**\n * Creates a function that can be called on responses to format the error then fire the cb\n *\n * @private\n * @param {Function} [cb]\n * @return {Function}\n */\nfunction errorFormatter(cb) {\n  const callback = typeof cb === 'function' ? cb /* no op */ : (function() {});\n  return function(err, result) {\n    if (err) {\n      callback(err, result);\n    } else {\n      if (result.status === 'ERROR') {\n        if (result.statusInfo === 'invalid-api-key') {\n          callback(\n            {\n              error: result.statusInfo,\n              code: result.statusInfo === 'invalid-api-key' ? 401 : 400\n            },\n            null\n          );\n        }\n      } else {\n        callback(err, result);\n      }\n    }\n  };\n}\n\n/**\n * Visual Recognition v3\n *\n * Normal usage requires an API key.\n * Dedicated instances require a username and password.\n *\n * @param {Object} options\n * @constructor\n */\nfunction VisualRecognitionV3(options) {\n  BaseService.call(this, options);\n  // Check if 'version_date' was provided\n  if (typeof this._options.version_date === 'undefined') {\n    throw new Error('Argument error: version_date was not specified, use 2016-05-20');\n  }\n  this._options.qs.version = this._options.version_date; // todo: confirm service expects version not version_date\n}\nutil.inherits(VisualRecognitionV3, BaseService);\nVisualRecognitionV3.prototype.name = 'visual_recognition';\nVisualRecognitionV3.prototype.version = 'v3';\nVisualRecognitionV3.URL = 'https://gateway-a.watsonplatform.net/visual-recognition/api';\nVisualRecognitionV3.prototype.serviceDefaults = {\n  alchemy: true\n};\n\n/**\n * Wrapper for requestFactory that ensures things are formatted the way the service likes\n *\n * @private\n * @param {Object} parameters\n * @param {Function} cb\n */\nVisualRecognitionV3.prototype.request = function(parameters, cb) {\n  const qs = parameters.options.qs;\n  if (qs) {\n    // array params are turned into a comma-separated string when in querystrings\n    Object.keys(qs).forEach(k => Array.isArray(qs[k]) && (qs[k] = qs[k].join(',')));\n  }\n  return requestFactory(parameters, cb);\n};\n\n/**\n * Grab the api key\n *\n * @param {Object} options\n * @private\n * @return {Object} new options object\n */\nVisualRecognitionV3.prototype.initCredentials = function(options) {\n  options.api_key = options.api_key || options.apikey;\n  options = extend({}, this.getCredentialsFromBluemix(this.name), this.getCredentialsFromEnvironment(this.name), options);\n  if (!options.use_unauthenticated) {\n    if (!options.api_key && !(options.username && options.password)) {\n      throw new Error('Argument error: api_key or username/password was not specified');\n    }\n    // Per documentation, Alchemy* services use `apikey`, but Visual Recognition uses (`api_key`)\n    // (Either will work in most cases, but the VR Collections & Similarity Search beta only supports `api_key`)\n    options.qs = extend({ api_key: options.api_key }, options.qs);\n  }\n  return options;\n};\n\n/**\n * Pulls api_key from the VISUAL_RECOGNITION_API_KEY env property\n *\n * Also checks for VISUAL_RECOGNITION_USERNAME and VISUAL_RECOGNITION_PASSWORD for dedicated instances.\n *\n * @param {String} name\n * @return {{api_key: String|undefined, username: String|undefined, password: String|undefined, url: String|undefined}}\n */\nVisualRecognitionV3.prototype.getCredentialsFromEnvironment = function(name) {\n  return extend(\n    {\n      api_key: process.env[name.toUpperCase() + '_API_KEY']\n    },\n    BaseService.prototype.getCredentialsFromEnvironment.call(this, name)\n  );\n};\n\n/**\n * Bluemix uses a different naming convention for VR v3 than for other services\n * @return {*}\n */\nVisualRecognitionV3.prototype.getCredentialsFromBluemix = function() {\n  return BaseService.prototype.getCredentialsFromBluemix.call(this, 'watson_vision_combined');\n};\n\n/**\n * Accepts either a url, a single image file, or a zip file with multiple\n * images (.jpeg, .png, .gif) and scores every available classifier\n * on each image. It then applies a threshold and returns the list\n * of relevant classifier scores for each image.\n *\n * @example\n * * {\n *   \"images\": [{\n *     \"classifiers\": [{\n *       \"classes\": [{\n *         \"class\": \"animal\",\n *         \"score\": 0.998771,\n *         \"type_hierarchy\": \"/animals\"\n *       }, {\n *         \"class\": \"mammal\",\n *         \"score\": 0.998499,\n *         \"type_hierarchy\": \"/animals/mammal\"\n *       }, {\n *         \"class\": \"dog\",\n *         \"score\": 0.900249,\n *         \"type_hierarchy\": \"/animals/pets/dog\"\n *       }, {\n *         \"class\": \"puppy\",\n *         \"score\": 0.5,\n *         \"type_hierarchy\": \"/animals/pets/puppy\"\n *       }],\n *       \"classifier_id\": \"default\",\n *       \"name\": \"default\"\n *     }],\n *     \"image\": \"dog.jpg\"\n *   }],\n *   \"images_processed\": 1\n * }\n *\n * @param {Object} params\n * @param {ReadStream|Buffer|Object} [params.images_file] The image file (.jpg, .png, .gif) or compressed (.zip) file of images to classify. The total number of images is limited to 20. Either images_file or url must be specified. The SDK attempts to determine content-type automatically, but this may be overridden by providing an object: {value: Buffer|Stream, options: {filename: 'file.ext', contentType: 'image/type'}}\n * @param {String} [params.url] The URL of an image (.jpg, .png, .gif). Redirects are followed, so you can use shortened URLs. The resolved URL is returned in the response. Either images_file or url must be specified.\n * @param {Array} [params.classifier_ids=['default']] An array of classifier IDs to classify the images against.\n * @param {Array} [params.owners=['me','IBM']] An array with the value(s) \"IBM\" and/or \"me\" to specify which classifiers to run.\n * @param {Number} [params.threshold] A floating point value that specifies the minimum score a class must have to be displayed in the response.\n * @param {Function} callback\n *\n * @return {ReadableStream|undefined}\n *\n */\nVisualRecognitionV3.prototype.classify = function(params, callback) {\n  try {\n    fixupImageParam(params);\n  } catch (e) {\n    callback(e);\n    return;\n  }\n\n  params = extend(\n    {\n      classifier_ids: ['default'],\n      owners: ['me', 'IBM']\n    },\n    params\n  );\n\n  let parameters;\n\n  if (params.images_file) {\n    parameters = {\n      options: {\n        url: '/v3/classify',\n        method: 'POST',\n        formData: {\n          images_file: params.images_file,\n          parameters: {\n            value: JSON.stringify(pick(params, ['classifier_ids', 'owners', 'threshold'])),\n            options: {\n              contentType: 'application/json'\n            }\n          }\n        },\n        headers: pick(params, 'Accept-Language')\n      },\n      defaultOptions: this._options\n    };\n  } else {\n    parameters = {\n      options: {\n        url: '/v3/classify',\n        method: 'GET',\n        json: true,\n        qs: pick(params, ['url', 'classifier_ids', 'owners', 'threshold']),\n        headers: pick(params, 'Accept-Language')\n      },\n      defaultOptions: this._options\n    };\n  }\n\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Accepts either a url, a single image file, or a zip file with multiple\n * images (.jpeg, .png, .gif) and attempts to extract faces and\n * identities. It then applies a threshold\n * and returns the list of relevant identities, locations, and metadata\n * for found faces for each image.\n *\n * @example\n * {\n *   \"images\": [{\n *     \"faces\": [{\n *       \"age\": {\n *         \"max\": 54,\n *         \"min\": 45,\n *         \"score\": 0.40459\n *       },\n *       \"face_location\": {\n *         \"height\": 131,\n *         \"left\": 80,\n *         \"top\": 68,\n *         \"width\": 123\n *       },\n *       \"gender\": {\n *         \"gender\": \"MALE\",\n *         \"score\": 0.993307\n *       },\n *       \"identity\": {\n *         \"name\": \"Barack Obama\",\n *         \"score\": 0.970688,\n *         \"type_hierarchy\": \"/people/politicians/democrats/barack obama\"\n *       }\n *     }],\n *     \"image\": \"obama.jpg\"\n *   }],\n *   \"images_processed\": 1\n * }\n *\n * @param {Object} params\n * @param {ReadStream} [params.images_file] The image file (.jpg, .png, .gif) or compressed (.zip) file of images to classify. The total number of images is limited to 15. Either images_file or url must be specified.\n * @param {String} [params.url] The URL of an image (.jpg, .png, .gif). Redirects are followed, so you can use shortened URLs. The resolved URL is returned in the response. Either images_file or url must be specified.\n * @param {Function} callback\n *\n * @return {ReadableStream|undefined}\n */\nVisualRecognitionV3.prototype.detectFaces = function(params, callback) {\n  try {\n    fixupImageParam(params);\n  } catch (e) {\n    callback(e);\n    return;\n  }\n\n  let parameters;\n\n  if (params.images_file) {\n    parameters = {\n      options: {\n        url: '/v3/detect_faces',\n        method: 'POST',\n        json: true,\n        formData: pick(params, ['images_file'])\n      },\n      defaultOptions: this._options\n    };\n  } else {\n    parameters = {\n      options: {\n        url: '/v3/detect_faces',\n        method: 'GET',\n        json: true,\n        qs: pick(params, ['url'])\n      },\n      defaultOptions: this._options\n    };\n  }\n\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Accepts either a url, single image file, or a zip file with multiple\n * images (.jpeg, .png, .gif) and attempts to recognize text\n * found in the image. It then applies a threshold\n * and returns the list of relevant locations, strings,  and metadata\n * for discovered text in each image.\n *\n * @example\n * {\n *   \"images\": [{\n *     \"image\": \"car.png\",\n *     \"text\": \"3 jag [brio]\",\n *     \"words\": [{\n *       \"line_number\": 0,\n *       \"location\": {\n *         \"height\": 53,\n *         \"left\": 204,\n *         \"top\": 294,\n *         \"width\": 27\n *       },\n *       \"score\": 0.50612,\n *       \"word\": \"3\"\n *     }, {\n *       \"line_number\": 0,\n *       \"location\": {\n *         \"height\": 32,\n *         \"left\": 264,\n *         \"top\": 288,\n *         \"width\": 56\n *       },\n *       \"score\": 0.958628,\n *       \"word\": \"jag\"\n *     }, {\n *       \"line_number\": 0,\n *       \"location\": {\n *         \"height\": 40,\n *         \"left\": 324,\n *         \"top\": 288,\n *         \"width\": 92\n *       },\n *       \"score\": 0.00165806,\n *       \"word\": \"brio\"\n *     }]\n *   }],\n *   \"images_processed\": 1\n * }\n *\n * @param {Object} params\n * @param {ReadStream} [params.images_file] The image file (.jpg, .png, .gif) or compressed (.zip) file of images to classify. The total number of images is limited to 10. Either images_file or url must be specified.\n * @param {String} [params.url] The URL of an image (.jpg, .png, .gif). Redirects are followed, so you can use shortened URLs. The resolved URL is returned in the response. Either images_file or url must be specified.\n * @param {Function} callback\n *\n * @return {ReadableStream|undefined}\n */\nVisualRecognitionV3.prototype.recognizeText = function(params, callback) {\n  try {\n    fixupImageParam(params);\n  } catch (e) {\n    callback(e);\n    return;\n  }\n\n  let parameters;\n\n  if (params.images_file) {\n    parameters = {\n      options: {\n        url: '/v3/recognize_text',\n        method: 'POST',\n        json: true,\n        formData: pick(params, ['images_file'])\n      },\n      defaultOptions: this._options\n    };\n  } else {\n    parameters = {\n      options: {\n        url: '/v3/recognize_text',\n        method: 'GET',\n        json: true,\n        qs: pick(params, ['url'])\n      },\n      defaultOptions: this._options\n    };\n  }\n\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Train a new classifier from example images which are uploaded.\n * This call returns before training has completed.  You'll need to use the\n * getClassifer method to make sure the classifier has completed training and\n * was successful before you can classify any images with the newly created\n * classifier.\n *\n * @example\n * {\n *   foo_positive_examples: fs.createReadStream('./foo-pics.zip'),\n *   negative_examples: fs.createReadStream('./not-foo-pics.zip'),\n *   name: 'to-foo-or-not'\n * }\n * @example\n * {\n *  foo_positive_examples: fs.createReadStream('./foo-pics.zip'),\n *  bar_positive_examples: fs.createReadStream('./bar-pics.zip'),\n *  name: 'foo-vs-bar'\n * }\n * @example\n * {\n *  foo_positive_examples: fs.createReadStream('./foo-pics.zip'),\n *  bar_positive_examples: fs.createReadStream('./bar-pics.zip'),\n *  negative_examples: fs.createReadStream('./not-foo-pics.zip'),\n *  name: 'foo-bar-not'\n * }\n *\n * @example\n * {\n *   \"classifier_id\": \"fruit_679357912\",\n *   \"name\": \"fruit\",\n *   \"owner\": \"a3a48ea7-492b-448b-87d7-9dade8bde5a9\",\n *   \"status\": \"training\",\n *   \"created\": \"2016-05-23T21:50:41.680Z\",\n *   \"classes\": [{\n *     \"class\": \"banana\"\n *   }, {\n *     \"class\": \"apple\"\n *   }]\n * }\n *\n * @param {Object} params\n * @param {String} params.name The desired short name of the new classifier.\n * @param {ReadStream} params.classname_positive_examples <your_class_name>_positive_examples One or more compressed (.zip) files of images that depict the visual subject for a class within the new classifier. Must contain a minimum of 10 images. You may supply multiple files with different class names in the key.\n * @param {ReadStream} [params.negative_examples] A compressed (.zip) file of images that do not depict the visual subject of any of the classes of the new classifier. Must contain a minimum of 10 images. Required if only one positive set is provided.\n *\n * @return {ReadableStream|undefined}\n */\nVisualRecognitionV3.prototype.createClassifier = function(params, callback) {\n  params = params || {};\n\n  const example_keys = Object.keys(params).filter(function(key) {\n    return key === NEGATIVE_EXAMPLES || key.match(/^.+_positive_examples$/);\n  });\n\n  if (example_keys.length < 2) {\n    callback(new Error('Missing required parameters: either two *_positive_examples or one *_positive_examples and one negative_examples must be provided.'));\n    return;\n  }\n  // todo: validate that all *_examples are streams or else objects with buffers and content-types\n  const allowed_keys = ['name', NEGATIVE_EXAMPLES].concat(example_keys);\n\n  const parameters = {\n    options: {\n      url: '/v3/classifiers',\n      method: 'POST',\n      json: true,\n      formData: pick(params, allowed_keys)\n    },\n    requiredParams: ['name'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Retrain a existing classifier from example images which are uploaded.\n * This call returns before retraining has completed.  You'll need to use the\n * getClassifer method to make sure the classifier has completed retraining and\n * was successful before you can classify any images with the retrained\n * classifier.\n *\n * @example\n * {\n *   \"classifier_id\": \"fruit_679357912\",\n *   \"name\": \"fruit\",\n *   \"owner\": \"a3a48ea7-492b-448b-87d7-9dade8bde5a9\",\n *   \"status\": \"training\",\n *   \"created\": \"2016-05-23T21:50:41.680Z\",\n *   \"classes\": [{\n *     \"class\": \"banana\"\n *   }, {\n *     \"class\": \"apple\"\n *   }]\n * }\n *\n * @param {Object} params\n * @param {ReadStream} params.classname_positive_examples <your_class_name>_positive_examples One or more compressed (.zip) files of images that depict the visual subject for a class within the classifier. You may supply multiple files with different class names in the key.\n * @param {ReadStream} [params.negative_examples] A compressed (.zip) file of images that do not depict the visual subject of any of the classes of the classifier.\n *\n * @return {ReadableStream|undefined}\n */\nVisualRecognitionV3.prototype.retrainClassifier = function(params, callback) {\n  params = params || {};\n\n  const allowed_keys = Object.keys(params).filter(function(key) {\n    return key === NEGATIVE_EXAMPLES || key.match(/^.+_positive_examples$/);\n  });\n\n  const parameters = {\n    options: {\n      url: '/v3/classifiers/' + params.classifier_id,\n      method: 'POST',\n      json: true,\n      formData: pick(params, allowed_keys)\n    },\n    requiredParams: [],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Retrieve a list of all classifiers, including built-in and\n * user-created classifiers.\n *\n * @example\n * {\n *   \"classifiers\": [{\n *     \"classifier_id\": \"fruit_679357912\",\n *     \"name\": \"fruit\",\n *     \"status\": \"ready\"\n *   }, {\n *     \"classifier_id\": \"Dogs_2017013066\",\n *     \"name\": \"Dogs\",\n *     \"status\": \"ready\"\n *   }]\n * }\n *\n * @param {Object} params\n * @param {Boolean} [params.verbose=false]\n * @param {Function} callback\n * @return {ReadableStream|undefined}\n */\nVisualRecognitionV3.prototype.listClassifiers = function(params, callback) {\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v3/classifiers',\n      qs: pick(params, ['verbose']),\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Retrieves information about a specific classifier.\n *\n * @example\n * {\n *   \"classifier_id\": \"fruit_679357912\",\n *   \"name\": \"fruit\",\n *   \"owner\": \"a3a42ea7-492b-448b-87d7-9dfde8bde519 \",\n *   \"status\": \"ready\",\n *   \"created\": \"2016-05-23T21:50:41.680Z\",\n *   \"classes\": [{\n *     \"class\": \"banana\"\n *   }, {\n *     \"class\": \"apple\"\n *   }]\n * }\n *\n * @param {Object} params\n * @param {Boolean} params.classifier_id The classifier id\n * @param {Function} callback\n * @return {ReadableStream|undefined}\n */\nVisualRecognitionV3.prototype.getClassifier = function(params, callback) {\n  const parameters = {\n    options: {\n      method: 'GET',\n      url: '/v3/classifiers/{classifier_id}',\n      path: params,\n      json: true\n    },\n    requiredParams: ['classifier_id'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Deletes a custom classifier with the specified classifier id.\n *\n * @param {Object} params\n * @param {String} params.classifier_id The classifier id\n * @param {Function} callback\n * @return {ReadableStream|undefined}\n */\nVisualRecognitionV3.prototype.deleteClassifier = function(params, callback) {\n  const parameters = {\n    options: {\n      method: 'DELETE',\n      url: '/v3/classifiers/{classifier_id}',\n      path: params,\n      json: true\n    },\n    requiredParams: ['classifier_id'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n// collections & similarity search\n\n/**\n * Create a collection\n * Beta. Create a new collection of images to search. You can create a maximum of 5 collections.\n *\n * Example response:\n\n   { collection_id: 'integration_test_1474313373701_d9665f',\n     name: 'integration_test_1474313373701',\n     status: 'available',\n     created: '2016-09-19T19:29:34.019Z',\n     images: 0,\n     capacity: 1000000 }\n\n * @param {Object} params\n * @param {String} params.name The name of the new collection. The name can be a maximum of 128 UTF8 characters, with no spaces.\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.createCollection = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v3/collections',\n      method: 'POST',\n      json: true,\n      formData: pick(params, ['name'])\n    },\n    requiredParams: ['name'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Retrieve collection details\n * Beta. Retrieve information about a specific collection.\n *\n * Example response:\n\n { collection_id: 'integration_test_1474313373701_d9665f',\n   name: 'integration_test_1474313373701',\n   status: 'available',\n   created: '2016-09-19T19:29:34.019Z',\n   images: 0,\n   capacity: 1000000 }\n\n * @param {Object} params\n * @param {String} params.collection_id\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.getCollection = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}',\n      method: 'GET',\n      json: true,\n      path: params\n    },\n    requiredParams: ['collection_id'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * List collections\n * Beta. List all custom collections.\n *\n * Example response:\n\n { collections:\n   [ { collection_id: 'integration_test_1474313967414_0e320b',\n       name: 'integration_test_1474313967414',\n       status: 'available',\n       created: '2016-09-19T19:39:27.811Z',\n       images: 0,\n       capacity: 1000000 } ] }\n\n * @param {Object} [params]\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.listCollections = function(params, callback) {\n  if (typeof params === 'function' && !callback) {\n    callback = params;\n  }\n\n  const parameters = {\n    options: {\n      url: '/v3/collections',\n      method: 'GET',\n      json: true\n    },\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Delete a collection\n * Beta. Delete a user created collection.\n *\n * @param {Object} params\n * @param {String} params.collection_id\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.deleteCollection = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}',\n      method: 'DELETE',\n      json: true,\n      path: params\n    },\n    requiredParams: ['collection_id'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Add an image to a collection\n * Beta. Add images to a collection. Each collection can contain 1000000 images.\n *\n * Example Response:\n\n {\n   \"images\": [\n     {\n       \"image_id\": \"9725bc\",\n       \"image_file\": \"obama.jpg\",\n       \"created\": \"2016-09-20T14:41:49.927Z\",\n       \"metadata\": {\n         \"foo\": \"bar\"\n       }\n     }\n   ],\n   \"images_processed\": 1\n }\n\n * @param {Object} params\n * @param {String} params.collection_id\n * @param {ReadableStream} params.image_file The image file (.jpg or .png) of the image to add to the collection. Maximum file size of 2 MB.\n * @param {Object} [params.metadata] optional arbitrary metadata. This can be anything that can be specified in a JSON object. For example, key-value pairs. Maximum 2 KB of metadata for each image.\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.addImage = function(params, callback) {\n  params = params || {};\n\n  if (!params.image_file || !isStream(params.image_file)) {\n    throw new Error('image_file param must be a standard Node.js Stream');\n  }\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}/images',\n      method: 'POST',\n      json: true,\n      path: params,\n      formData: {\n        image_file: params.image_file,\n        metadata: {\n          value: JSON.stringify(params.metadata || {}),\n          options: {\n            contentType: 'application/json',\n            filename: 'metadata.json' // it doesn't matter what the filename is, but the service requires that *some* filename be set or else it ignores the metadata\n          }\n        }\n      }\n    },\n    requiredParams: ['collection_id', 'image_file'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * List images in a collection\n * Beta. List the first 100 images in a collection. Each collection can contain 1000000 images.\n *\n * Example Response:\n\n{ images:\n  [ { image_id: '83f3ff',\n     image_file: 'obama.jpg',\n     created: '2016-09-19T21:07:15.141Z' } ] }\n *\n * @param {Object} params\n * @param {String} params.collection_id\n * @param {ReadableStream} params.image_file The image file (.jpg or .png) of the image to add to the collection. Maximum file size of 2 MB.\n * @param {Object} [params.metadata] optional arbitrary metadata. This can be anything that can be specified in a JSON object. For example, key-value pairs. Maximum 2 KB of metadata for each image.\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.listImages = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}/images',\n      method: 'GET',\n      json: true,\n      path: params\n    },\n    requiredParams: ['collection_id'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Get image details\n * Beta. List details about a specific image in a collection.\n *\n * Example Response:\n\n{ image_id: '83f3ff',\n  image_file: 'obama.jpg',\n  created: '2016-09-19T21:07:15.141Z'\n\n * @param {Object} params\n * @param {String} params.collection_id\n * @param {String} params.image_id\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.getImage = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}/images/{image_id}',\n      method: 'GET',\n      json: true,\n      path: params\n    },\n    requiredParams: ['collection_id', 'image_id'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Delete an image\n * Beta. Delete an image from a collection.\n *\n * @param {Object} params\n * @param {String} params.collection_id\n * @param {String} params.image_id\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.deleteImage = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}/images/{image_id}',\n      method: 'DELETE',\n      json: true,\n      path: params\n    },\n    requiredParams: ['collection_id', 'image_id'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Add or update metadata\n * Beta. Add metadata to a specific image in a collection.\n *\n * @param {Object} params\n * @param {String} params.collection_id\n * @param {String} params.image_id\n * @param {Object} params.metadata Can be anything that can be specified in a JSON object. For example, key-value pairs. Maximum 2 KB of metadata for each image.\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.setImageMetadata = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}/images/{image_id}/metadata',\n      method: 'PUT',\n      json: true,\n      path: params,\n      headers: { 'Content-Type': 'multipart/form-data' },\n      // todo: manually create a body string that looks like a POST form data body even though it's a PUT\n      formData: {\n        metadata: {\n          value: JSON.stringify(params.metadata || {}),\n          options: {\n            contentType: 'application/json',\n            filename: 'metadata.json' // it doesn't matter what the filename is, but the service requires that *some* filename be set or else it gives a confusing \"Missing multipart/form-data\" error\n          }\n        }\n      }\n    },\n    requiredParams: ['collection_id', 'image_id', 'metadata'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Get image metadata\n * Beta. View the metadata for a specific image in a collection.\n *\n * Example Response:\n\n {\"foo\": \"bar\"}\n\n *\n * @param {Object} params\n * @param {String} params.collection_id\n * @param {ReadableStream} params.image_id\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.getImageMetadata = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}/images/{image_id}/metadata',\n      method: 'GET',\n      json: true,\n      path: params\n    },\n    requiredParams: ['collection_id', 'image_id'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Delete image metadata\n * Beta. Delete all metadata associated with an image.\n *\n * @param {Object} params\n * @param {String} params.collection_id\n * @param {ReadableStream} params.image_id\n * @param {Function} callback\n */\nVisualRecognitionV3.prototype.deleteImageMetadata = function(params, callback) {\n  params = params || {};\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}/images/{image_id}/metadata',\n      method: 'DELETE',\n      json: true,\n      path: params\n    },\n    requiredParams: ['collection_id', 'image_id'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\n/**\n * Find similar images\n * Beta. Upload an image to find similar images in your custom collection.\n *\n * Example response:\n\n {\n    \"similar_images\":[\n       {\n          \"image_id\":\"dresses_1257263\",\n          \"created\":\"2016-09-04T21:49:16.908Z\",\n          \"metadata\":{\n             \"weight\":10,\n             \"cut\":\"a line\",\n             \"color\":\"red\"\n          },\n          \"score\":\"0.79\"\n       }\n    ],\n    \"image_file\":\"red_dress.jpg\",\n    \"images_processed\": 1\n }\n\n * @param {Object} params\n * @param {String} params.collection_id The collection id\n * @param {ReadableStream} params.image_file The image file (.jpg or .png) of the image to search against the collection.\n * @param {Number} [params.limit=10]  limit The number of similar results you want returned. Default limit is 10 results, you can specify a maximum limit of 100 results.\n * @param {Function} callback\n * @return {ReadableStream|undefined}\n */\nVisualRecognitionV3.prototype.findSimilar = function(params, callback) {\n  params = params || {};\n\n  if (!params.image_file || !isStream(params.image_file)) {\n    throw new Error('image_file param must be a standard Node.js Stream');\n  }\n\n  const parameters = {\n    options: {\n      url: '/v3/collections/{collection_id}/find_similar',\n      method: 'POST',\n      json: true,\n      qs: pick(params, ['limit']),\n      formData: pick(params, ['image_file']),\n      path: pick(params, ['collection_id'])\n    },\n    requiredParams: ['collection_id', 'image_file'],\n    defaultOptions: this._options\n  };\n  return this.request(parameters, errorFormatter(callback));\n};\n\nmodule.exports = VisualRecognitionV3;\n"}